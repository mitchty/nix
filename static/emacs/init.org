#+TITLE: Emacs Configuration
#+AUTHOR: Mitchell Tishmack
#+STARTUP: hidestars
#+STARTUP: odd
#+BABEL: :cache yes
#+PROPERTY: header-args :cache yes
#+PROPERTY: header-args :padline no
#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: header-args :comments no
#+PROPERTY: header-args :results replace

* Emacs config

Use use-package to configure emacs itself.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package emacs
  :ensure
  :demand t
  :bind ("C-x ," . kill-whole-line)
  :hook
  ((prog-mode text-mode org-mode) . hl-line-mode)
  ((after-init) . recentf-mode)
  :config
  (setq-default debug-on-error t)
  (setq-default bidi-paragraph-direction 'left-to-right)
  (setq kill-buffer-query-functions
      (remq 'process-kill-buffer-query-function kill-buffer-query-functions))
  (show-paren-mode)
  (load "server")
  (unless (server-running-p) (server-start))
  (defun my-minibuffer-setup-hook ()
    (setq gc-cons-threshold most-positive-fixnum))
  (defun my-minibuffer-exit-hook ()
    (setq gc-cons-threshold 8000000))
  (defun string/ends-with (string suffix)
    "Return t if STRING ends with SUFFIX."
    (and (string-match (rx-to-string `(: ,suffix eos) t)
                       string)
         t))
  (defvar on-mswindows (string-match "windows" (symbol-name system-type))
    "Am I running under windows?")
  (defvar on-osx (string-match "darwin" (symbol-name system-type))
    "Am I running under osx?")
  (defvar on-linux (string-match "gnu/linux" (symbol-name system-type))
    "Am I running under linux?")
  (add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
  (add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook)
  (fset 'yes-or-no-p 'y-or-n-p)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq inhibit-startup-screen t)
  (setq enable-recursive-minibuffers t)
  (setq native-comp-async-report-warnings-errors 'silent)
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
  (add-hook 'dired-load-hook (function (lambda () (load "dired-x"))))
  (add-hook 'after-init-hook (function (lambda () (make-directory temporary-file-directory :parents))))
  (put 'upcase-region 'disabled nil)

  (delete-selection-mode 1)

  (set-language-environment "UTF-8")
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (tooltip-mode -1)
  :custom
  (tooltip-use-echo-area t)
  (recentf-max-menu-items 15)
  (recentf-max-saved-items 100)
  (locale-coding-system 'utf-8)
  (frame-inhibit-implied-resize t)
  (inhibit-startup-echo-area-message t)
  (inhibit-startup-message t)
  (inhibit-startup-screen t)
  (initial-scratch-message nil)
  (pixel-scroll-precision-mode t)
  (temporary-file-directory "/tmp/.emacs/")
  (backup-directory-alist `((".*" . ,temporary-file-directory)))
  (auto-save-file-name-transforms `((".*" ,temporary-file-directory t)))
  (create-lockfiles nil)
  (make-backup-files nil)
  (auto-save-default nil)
  (backup-by-copying t)
  (auto-save-list-file-prefix temporary-file-directory)

  (use-dialog-box nil)
  (history-length 50)
  (savehist-mode 1)
  (save-place-mode 1)

  (global-auto-revert-mode 1)
  (global-auto-revert-non-file-buffers t)
  (auto-revert-remote-files t)

  (word-wrap t)
  (default-major-mode 'text-mode)
  (fill-column 80)
  (sentence-end "[.?!][]\"')]*\\($\\|\t\\| \\)[ \t\n]*")
  (sentence-end-double-space nil)
  (default-tab-width 2)
  (redisplay-dont-pause t)
  (vc-handled-backends '(Git))
  ;; we get packages from the overlay never from the internet directly
  (package-archives ()))
#+END_SRC

*** use-package debugging

Cause the macros *use-packge* can generate are... not entirely easy to debug. This helps make it easier than using builtins.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package macrostep
  :ensure
  :after elisp-mode
  :bind
  (:map emacs-lisp-mode-map
        ("C-c e"   . macrostep-expand)
        ("C-c C-e" . macrostep-expand)))
#+END_SRC

View epub's in emacs directly https://depp.brause.cc/nov.el/

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package nov
  :ensure
  :defer
  :config
  (setq nov-text-width 80)
  :mode (("\\.epub\\'" . nov-mode)))
#+END_SRC

minimap so my emacs can be more like the cool kids, won't turn it on everywhere yet only when i want it for now.

FUTURE MITCH DO NOT ADD *text-mode* or magit will get the minimap too probably a lot of other stuff too listen to jerk past you for once, this comment isn't here for funsies no cap.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package minimap
  :if (memq window-system '(mac ns))
  :ensure
  :defer
  :diminish minimap-mode
  :bind (("C-x i" . minimap-create))
  :custom
  (minimap-minimum-width 20)
  (minimap-major-modes '(prog-mode org-mode nix-mode))
  (minimap-recreate-window t)
  (minimap-update-delay 0)
  (minimap-window-location 'left))
#+END_SRC

*** recentf setup

Note that the defaults for this are setup in the emacs package.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package init-open-recentf
  :ensure
  :after emacs
  ;; :custom (init-open-recentf-interface 'counsel)
  :config (init-open-recentf))
#+END_SRC

*** theme setup

Sick of solarized, going back to good old black on white minimalism like paper. Also note auto-dark is macos only.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package zenburn-theme :ensure)
(use-package minimal-theme :ensure)

(use-package auto-dark
  :if (memq window-system '(mac ns))
  :after (minimal-theme zenburn-theme)
  :ensure
  :defer
  :init
  (auto-dark-mode)
  :custom
  (auto-dark--dark-theme 'zenburn)
  (auto-dark--light-theme 'minimal-light))
#+END_SRC

*** whitespace

Customize whitespace mode to make tabs obvious as boxes, and to highlight lines over 80 characters in length.

This breaks in :hook for some reason I can't be assed to figure out.

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'whitespace)
(global-visual-line-mode)
(setq whitespace-style '(face tabs trailing))

(set-face-attribute 'whitespace-tab nil
                    :foreground "#2075c7"
                    :background "lightgrey")

(set-face-attribute 'whitespace-line nil
                    :foreground "#2075c7"
                    :background "lightgrey")
(add-hook 'prog-mode-hook 'whitespace-mode)
(add-hook 'text-mode-hook 'whitespace-mode)
(add-hook 'makefile-mode-hook 'whitespace-mode)
(add-hook 'org-mode-hook 'whitespace-mode)
#+END_SRC

*** osx specific
**** make osx gui emacs keyboard setup match console

Command should be meta on cocoa emacs like the old carbon/macports version.

#+BEGIN_SRC emacs-lisp :tangle yes
(when (and on-osx (window-system))
  (custom-set-variables
   '(mac-command-key-is-meta t)
   '(mac-option-key-is-meta nil)
   '(mac-command-key-is-meta t)
   '(mac-command-modifier 'meta)
   '(mac-option-modifier 'none)
   )
  )
#+END_SRC

*** x copy/paste

#+BEGIN_SRC emacs-lisp :tangle yes
(when (and on-linux (window-system))
  (progn
    (setq interprogram-paste-function 'x-cut-buffer-or-selection-value)
    (setq select-enable-clipboard t)
    )
  )
#+END_SRC
* appearance
*** focus on current text

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dimmer :ensure)
#+END_SRC

*** fonts setup

TODO: Migrate this into the top use-package setup
Set the default frame list values, then iff in a window system set the fonts in reverse order of preference

#+BEGIN_SRC emacs-lisp :tangle yes
(setq default-frame-alist
      (append (list
               '(right-fringe . 0)
               '(min-height . 1)
               '(height     . 42)
               '(foreground-color . "#333333")
               '(background-color . "#ffffff")
               '(cursor-color . "black")
               '(internal-border-width . 1)
               '(tool-bar-lines . 0)
               '(menu-bar-lines . 0))))
#+END_SRC

List of fonts in order of preference. Set preferred font list when we're in a gui emacs session. Note order of the list is in reverse so we set the least desired fonts and end with the more desired if available

#+BEGIN_SRC emacs-lisp :tangle yes
(with-no-warnings
  (mapcar (lambda (element)
            (when (and window-system (find-font (font-spec :name element))
                       (progn (set-frame-font element)
                              (set-face-attribute 'default nil :height 180))
                       )))
          '(
            "Monaco"
            "Menlo"
            "Source Code Pro"
            "Pragmata Pro" ;; Seems to register differently on osx than X
            "PragmataPro"
            "Comic Code"
            "ComicCode"
            )
          ))
#+END_SRC

*** tty

   Enable mouse mode for the console and use the mousewheel if possible.

#+BEGIN_SRC emacs-lisp :tangle yes
(unless window-system
  (require 'mouse)
  (xterm-mouse-mode t)
  (global-set-key [mouse-4] '(lambda ()
                               (interactive)
                               (scroll-down 1)))
  (global-set-key [mouse-5] '(lambda ()
                               (interactive)
                               (scroll-up 1)))
  (defun track-mouse (e))
  )
#+END_SRC

* packages

All the packages I use.
*** diminish

Keep useless mode line entries down a skosh.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package diminish :ensure)
#+END_SRC

*** editorconfig

If editorconfig is around use it.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package editorconfig
  :diminish
  :ensure
  :defer
  :config
  (editorconfig-mode 1))
#+END_SRC

*** tramp

#+BEGIN_SRC emacs-lisp :tangle yes
;; Turn vc mode off in find-file cause if its removed who gives a crap if its in
;; version control?

(defun vc-off-if-remote ()
  (if (file-remote-p (buffer-file-name))
      (setq-local vc-handled-backends nil)))
(add-hook 'find-file-hook 'vc-off-if-remote)

(use-package tramp
  :after emacs
  :custom
  (tramp-default-method "ssh")
  (vc-handled-backends '(Git))
  :config
  (add-to-list 'tramp-default-proxies-alist '(".*" "\`root\'" "/ssh:%h:"))
  )
#+END_SRC

*** envrc-mode

Direnv and *.envrc* integration/automagic stuff in emacs too.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package envrc
  :defer
  :ensure
  :diminish envrc-mode
  :commands envrc-global-mode
  :init
  (envrc-global-mode))
#+END_SRC

*** exec-path-from-shell

Turns out that someone wrote this exact thing already. Yay get to drop my own crap.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  :ensure
  :config
  (exec-path-from-shell-initialize)
  )
#+END_SRC

*** silver searcher

Use the silver searcher for quick searches.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ag :ensure :defer)
#+END_SRC

*** osx-clipboard-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package osx-clipboard
  :if (memq window-system '(mac ns))
  :ensure
  :config
  (osx-clipboard-mode +1))
#+END_SRC

*** mode-line setup

Converted this all back to straight up manual mode line setup, all the packages take too much cpu and slow stuff down. Easier to just do what I want here than use all that extra elisp I don't use.

TODO: Need to customize the faces in the mode line to cover the atrocious
defaults. Future me task, also need to integrate my flycheck lighter in so I can
get error/warning/info summaries when present that link to the
errors/warnings/whatever. And put in the start..end region thing too to replace
line:column when a regions selected like I had. Mostly just copypastad a lot of
crap I found on github.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my-flycheck-lighter (state)
  "formats the mode-line fycheck error/warning/note junk"
  (let* ((counts (flycheck-count-errors flycheck-current-errors))
         (errorp (flycheck-has-current-errors-p state))
         (err (or (cdr (assq state counts)) "?"))
         (running (eq 'running flycheck-last-status-change)))
    (if (or errorp running) (format "•%s" err))))

(display-battery-mode 1)
(setq-default battery-mode-line-format "%b%p%% %t")

(setq-default mode-line-format
  (list "%e"
        mode-line-front-space
        '(:eval (when (file-remote-p default-directory)
                  (propertize "%1@"
                              'mouse-face 'mode-line-highlight
                              'help-echo (concat "remote: " default-directory))))
        '(:eval (cond (buffer-read-only "ro ")
                      ((buffer-modified-p) "! ")
                      (t " ")))
        '(:eval (propertize "%12b" 'face 'mode-line-buffer-id 'help-echo default-directory))
        mode-line-front-space
        '(:eval (let* ((vc-state (if (stringp vc-mode)
                                     (let* ((branch-name (replace-regexp-in-string
                                                          (format "^\s*%s:?-?" (vc-backend buffer-file-name))
                                                          ""
                                                          vc-mode))
                                            (formatted-branch-name branch-name)
                                            (buffer-vc-state (vc-state buffer-file-name))
                                            (f (cond ((string= "up-to-date" buffer-vc-state)
                                                      '((:slant normal)))
                                                     (t
                                                      '((:slant italic))))))
                                       (propertize formatted-branch-name 'face f))
                                   ""))
                       (ctr (format-mode-line (list  vc-state))))
                  (list ctr)))
        mode-line-front-space
        '(:eval (let* ((row (format-mode-line (list (propertize "%l" 'help-echo "Line number"))))
                       (col (format-mode-line (list ":" (propertize "%c" 'help-echo "Column number")))))
                  (list row col)))
        mode-line-front-space
        '(:eval (when (and (bound-and-true-p flycheck-mode)
                                        (or flycheck-current-errors
                                            (eq 'running flycheck-last-status-change)))
                               (concat
                                " "
                                (cl-loop for state in '((error . "#FB4933")
                                                        (warning . "#FABD2F")
                                                        (info . "#83A598"))
                                         as lighter = (my-flycheck-lighter (car state))
                                         when lighter
                                         concat (propertize
                                                 lighter
                                                 'help-echo state
                                                 'face `(:foreground ,(cdr state))))
                                )))
        ;; Only append in the battery thingy on macos, don't have nixos/linux
        ;; laptops... yet?
        (if (memq window-system '(mac ns)) mode-line-front-space)
        (if (memq window-system '(mac ns)) 'battery-mode-line-string)

))
        ;; TODO: Port this over too at some point in a boring meeting or
        ;; whatever, the examples I found for line/column number were easier to
        ;; put in but that could probably just be the else clause to if we're in
        ;; a region predicate? Future me figure out past me's a jerk and just
        ;; wants mini-modeline to stop being ass at not loading.
        ;; '(:eval (if (use-region-p)
        ;;                                (if (eq (point) (region-beginning))
        ;;                                    (format "%%l … %d" (line-number-at-pos (region-end)))
        ;;                                  (format "%d … %%l" (line-number-at-pos (region-beginning))))
        ;;                              ":%l"))
#+END_SRC

*** yasnippet

#+BEGIN_SRC emacs-lisp :tangle no
(use-package yasnippet
  :ensure
  :init
  (setq yas-snippet-dirs
        '("~/.emacs.d/snippets"
          "~/.emacs.d/snippets-upstream"
          ))
  :config
  (yas/reload-all)
  :hook ((prog-mode text-mode org-mode) . yas-minor-mode))
#+END_SRC

*** expand-region

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package expand-region
  :ensure
  :bind ("C-]" . er/expand-region))
#+END_SRC

*** ivy/swiper/projectile

Switching to ivy mode+swiper

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package counsel
  :ensure
  :bind (("C-x C-f" . counsel-find-file)
         ("C-c g" . counsel-git)
         ("C-c j" . counsel-git-grep)
         ("C-c k" . counsel-ag)
         ("C-x l" . counsel-locate)
         ("C-S-o" . counsel-rhythmbox)
         ("C-c C-r" . ivy-resume))
  :custom
  (counsel-find-file-at-point t))

(use-package swiper
  :ensure
  :bind (("C-s" . swiper)
         ("M-x" . counsel-M-x))
  :config
  (ivy-mode 1)
  :custom
  (projectile-completion-system 'ivy)
  (magit-completing-read-function 'ivy-completing-read)
  (ivy-use-virtual-buffers t)
  (ivy-height 10)
  (ivy-count-format "(%d/%d) "))

(use-package projectile
  :ensure
  :custom
  (projectile-cache-file (concat temporary-file-directory "/projectile.cache"))
  (projectile-known-projects-file (concat temporary-file-directory "/projectile.projects"))
  (projectile-enable-caching t)
  ;; (projectile-globally-ignored-files (quote ("TAGS" "GTAGS" "result")))
  :config
  (projectile-global-mode))

(use-package counsel-projectile
  :ensure
  :after counsel
  :config (counsel-projectile-mode))
#+END_SRC

*** magit

Make git not ass to use. At least in emacs. magit is the best git interface... in the world.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit
  :diminish
  :ensure
  :commands (magit-init
             magit-status
             magit-diff
             magit-commit)
  :bind ("C-x m" . magit-status)
  :custom
  (magit-auto-revert-mode nil)
  (magit-last-seen-setup-instructions "1.4.0")
  :config
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))
  (defadvice magit-quit-window (around magit-restore-screen activate)
    ad-do-it
    (jump-to-register :magit-fullscreen)))
#+END_SRC

And add TODO detection to the magit buffer. That way they get bubbled up to the
top to look at.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit-todos
  :ensure
  :after magit
  :hook (magit-mode . magit-todos-mode))
#+END_SRC

Also setup magit-lfs mode so we can do git lfs interaction.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit-lfs
  :ensure
  :after magit)
#+END_SRC

*** TODO org-mode                                        :validation:testing:

Org-mode keybindings and settings, pretty sparse really.

Todo is to figure out what needs to happen for the capture templates and
validate the agenda changes.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun capture-file-extension(extension)
  (if (eq extension nil) ""
    (if (string-match-p "\\." extension)
        extension
      (concat "." extension))))

(defun capture-date-file(path &optional extension)
  (setq prefix (expand-file-name (concat path (format-time-string "/%Y/%B"))))
  (mkdir prefix t)
  (setq file-name (format-time-string "%Y-%m-%d:%H:%M:%S"))
  (format "%s/%s%s" prefix file-name (capture-file-extension extension)))

(use-package ob-go :ensure)

(use-package org
  :defer
  :ensure
  :bind (("C-c a" . org-agenda)
         ("C-c b" . org-iswitchb)
         ("C-c c" . org-capture)
         ("C-c l" . org-store-link)
         ("C-c p" . org-latex-export-to-pdf))
  :init
  (require 'org-tempo)
  :config
  (add-to-list 'org-structure-template-alist '("cc" . "SRC c"))
  (add-to-list 'org-structure-template-alist '("el" . "SRC emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("go" . "SRC go"))
  (add-to-list 'org-structure-template-alist '("hs" . "SRC haskell"))
  (add-to-list 'org-structure-template-alist '("pl" . "SRC perl"))
  (add-to-list 'org-structure-template-alist '("py" . "SRC python"))
  (add-to-list 'org-structure-template-alist '("rs" . "src rust"))
  (add-to-list 'org-structure-template-alist '("sh" . "src sh"))
  (org-babel-do-load-languages
   'org-babel-load-languages
   (append org-babel-load-languages
           '(
             (C . t)
             (ditaa . t)
             (emacs-lisp . t)
             (go . t)
             (latex . t)
             (perl . t)
             (python . t)
             (ruby  . t)
             (shell . t)
             )))
  :custom
  (org-directory "~/src/pub/git.mitchty.net/mitchty/org")
  ;; Don't sort-lines ^^^
  (org-agenda-span 'fortnight)
  (org-archive-directory (concat org-directory "/attic"))
  (org-confirm-babel-evaluate nil)
  (org-default-notes-file (concat org-directory "/notes.org"))
  (org-fontify-done-headline t)
  (org-hide-emphasis-markers t)
  (org-hide-leading-stars t)
  (org-log-done t)
  (org-pretty-entities t)
  (org-src-preserve-indentation t)
  (org-src-strip-leading-and-trailing-blank-lines t)
  ;; Ref https://orgmode.org/manual/Template-elements.html for more detail.
  (org-agenda-files
   (list org-directory
         "~/src/pub/github.com/mitchty/nix"))
  ;;      "#+TITLE: %a\n#+ROAM_KEY: %U\n\n [[%U][%U]]\n"
  (org-capture-templates
   '(
;; TODO: make this crap work somehow
     ;; ("w" "website"
     ;;  entry (file (capture-date-file "~/src/org/ref/url" "org"))
     ;;  ;; "#+TITLE: %a\n#+ROAM_KEY: %U\n\n%? [[%U][%U]]\n"
     ;;  "%?"
     ;;  :prepend t :empty-lines 1)
     ;; ("u" "unsorted note"
     ;;  entry (file capture-date-file "~/src/org/unsorted" "org")
     ;;  "\n* %?\nRandom Note entered on %U\n  %i\n  %a\n"
     ;;  :prepend t :empty-lines 1)
     ;; ("r" "ref url"
     ;;  entry (file capture-date-file "~/src/org/ref/url")
     ;;  "\n* %?\nRandom Note entered on %U\n  %i\n  %a\n"
     ;;  :prepend t :empty-lines 1)
     ("d" "deadline"
      entry (file+headline org-default-notes-file "Todos")
      "* PRIO %? \nDEADLINE: %t"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     ("t" "todo"
      entry (file+headline org-default-notes-file "Todos")
      "* TODO %?\n  %i\n  %a\n"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     ("n" "note"
      entry (file+headline org-default-notes-file "Notes")
      "\n* %?\nRandom Note entered on %U\n  %i\n  %a\n"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     ("m" "email todo"
      entry (file+headline org-default-notes-file "Inbox")
      "\n* TODO %?, Link: %a\n"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     ("u" "urls"
      entry (file+headline org-default-notes-file "Urls")
      "\n** TODO read url :url:\n[[%?]]\n"
      :prepend t :empty-lines 1)
     ("i" "interruption"
      entry (file+headline org-default-notes-file "Interruptions")
      "\n* BLOCKED by %? :BLOCKED:\n%t"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     ("j" "journal"
      entry (file (concat org-directory "/journal.org"))
      "* %?\n%U\n"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     )))
#+END_SRC

**** TODO org babel ob-async testing                             :validation:

Validate that this installs from scratch fine, blocking babel executions is ass.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ob-async :after org :ensure)
#+END_SRC

**** org-journal                                                 :validation:

Try out org journal https://github.com/bastibe/org-journal

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-journal
  :ensure
  :defer
  :bind ("M-g j" . org-journal-new-entry)
  :custom
  (org-journal-prefix-key "C-c j ")
  (org-journal-find-file 'find-file)
  (org-journal-file-format "%Y%m%d.org")
  (org-journal-dir (concat org-directory "/journal")
        org-journal-date-format "%A, %d %B %Y"))
#+END_SRC

**** TODO org-habit customization                                   :testing:

Figure out the customization needed here. Note that org-habit isn't a feature we can use-package against.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'org-modules 'org-habit)
(custom-set-variables
 '(org-habit-graph-column 44)
 '(org-habit-preceding-days 31)
 '(org-habit-following-days 7))
#+END_SRC

**** TODO org-bullets review if alternative is worth it          :validation:

https://github.com/integral-dw/org-superstar-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-bullets
  :after org
  :ensure
  :custom
  (org-bullets-bullet-list '("◉" "○" "✸" "✿" "✜" "◆" "▶"))
  (org-ellipsis "↴")
  :hook (org-mode . org-bullets-mode)
  :config
  (when window-system
    (let* ((variable-tuple (cond ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
                                 ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
                                 ((x-list-fonts "Verdana")         '(:font "Verdana"))
                                 ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
                                 (nil (warn "Cannot find a Sans Serif Font."))))
           (base-font-color     (face-foreground 'default nil 'default))
           (headline           `(:inherit default :weight bold :foreground ,base-font-color)))
      (custom-theme-set-faces 'user
                              `(org-level-8 ((t (,@headline ,@variable-tuple))))
                              `(org-level-7 ((t (,@headline ,@variable-tuple))))
                              `(org-level-6 ((t (,@headline ,@variable-tuple))))
                              `(org-level-5 ((t (,@headline ,@variable-tuple))))
                              `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
                              `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.25))))
                              `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.5))))
                              `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.75))))
                              `(org-document-title ((t (,@headline ,@variable-tuple :height 1.5 :underline nil)))))))
  (font-lock-add-keywords 'org-mode
                          '(("^ +\\([-*]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
  )
#+END_SRC

**** TODO org-download                                              :testing:

Start using this or try to deal with say screenshots for org-journal or whatever notes.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-download
  :defer t
  :ensure
  :after org
  :config
  (require 'org-download)
  (add-hook 'dired-mode-hook 'org-download-enable))
#+END_SRC

*** flycheck

Flycheck for on the fly checking of code.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck
  :ensure
  :custom
  (flycheck-indication-mode 'left-fringe)
  (flycheck-highlighting-mode 'symbols)
  (flycheck-highlighting-style 'level-face)
  :hook (prog-mode . flycheck-mode))
#+END_SRC

*** TODO wucuo

Spellcheek is useful.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package wucuo
  :ensure
  :hook (text-mode . wucuo-mode))
#+END_SRC

*** auto-complete

Auto complete functionality is nice to have.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package auto-complete
  :ensure
  :init
  (require 'auto-complete-config)
  (ac-config-default)
  (global-auto-complete-mode t)
  )
#+END_SRC

*** smartparens

Helpfully inserts matching parens, can be a pita too.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smartparens
  :ensure
  :hook (prog-mode . smartparens-mode))
#+END_SRC

*** rainbow delimiters

Makes matching parens easier.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :ensure
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

*** uniquify

Make buffer names unique based on their directory and not have <N> or other nonsense.

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'uniquify)
(custom-set-variables '(uniquify-buffer-name-style 'post-forward))
#+END_SRC

*** TODO super-save

Ok so super save is kinda sus, with eglot+auto format on saves I'm getting competing writes and ending up with garbage at the end of some rust files. ITS THE DUMBEST THING EVER.

So for now lets turn it off entirely, can go back to old school always save defensively.

Saves buffers like with auto-save but on focus loss, when idle etc...

#+BEGIN_SRC emacs-lisp :tangle no
(use-package super-save
  :diminish
  :ensure
  :config
  (super-save-mode +1)
  (setq super-save-auto-save-when-idle t)
  (setq auto-save-default nil)
  )
#+END_SRC

*** diff-hl

Shows in the fringe the status of lines added/removed/modified. Seems a skosh slow.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package diff-hl
  :ensure
  :config
  (global-diff-hl-mode))
#+END_SRC

*** highlight indentation setup

This mode is neat-o cuase it can highlight/block highlight indentation n stuff.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package highlight-indent-guides
  :ensure
  :custom
  (highlight-indent-guides-method 'fill)
  (highlight-indent-guides-suppress-auto-error t) ;; This spits out an error when I test and confuses the crap out of me when I see it but its due to starting emacs on macos as a daemon, so... ignore it whatever.
  (highlight-indent-guides-responsive 'stack)
  :hook (prog-mode . highlight-indent-guides-mode))
#+END_SRC

*** git gutter

#+BEGIN_SRC emacs-lisp :tangle no
(use-package git-gutter
  :ensure
  :config
  (global-git-gutter-mode t)
  )
#+END_SRC

*** clang-format

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package clang-format
  :ensure
  :bind (([C-M-tab] . clang-format-region))
  )
#+END_SRC

*** tree-sitter

Since 29.1ish or whatever has it now lets just use it for all the things new hotness and avoid ide's like the plague as is tradition.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package tree-sitter
  :ensure
  :config
  (require 'tree-sitter)
  (global-tree-sitter-mode 1))
(use-package tree-sitter-langs
  :after tree-sitter
  :ensure
  :hook
  (tree-sitter-after-on . tree-sitter-hl-mode)
  :config
  (require 'tree-sitter-langs))
(use-package tsc :ensure :after tree-sitter-langs)
#+END_SRC

*** eglot/lsp-mode

Also start using the lsp-mode stuff in 29.x or whatever too. If it works well enough maybe flycheck goes away? Doubt it cause eglots got that correct error at point integration to do an autofix soooo future me figure it out.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package eglot
  :ensure
  :hook ((sh-mode go-mode rust-mode nix-mode python-mode c-mode cc-mode yaml-mode dockerfile-mode markdown-mode json-mode) . eglot-ensure))

(use-package lsp-mode :after eglot :ensure)

(use-package flycheck-eglot
  :ensure
  :after (flycheck eglot)
  :config
  (global-flycheck-eglot-mode 1))
#+END_SRC

*** yaml-mode

For.. yaml

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yaml-mode
  :ensure
  :hook (yaml-mode . whitespace-mode)
  )
#+END_SRC

*** markdown-mode

Make markdown pretty(er/ish)

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package markdown-mode
  :ensure
  :hook (markdown-mode . whitespace-mode)
  )
#+END_SRC

*** writegood-mode

So I write gooder. Me fail English? Thats unpossible.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package writegood-mode :ensure)
#+END_SRC

*** rust-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rust-mode
  :ensure
  :commands rust-mode)

(use-package rustic
  :after eglot
  :ensure
  :custom
  (rustic-rustfmt-config-alist '((edition . "2021")))
;;  (rustic-format-on-save t)
  (rustic-lsp-client 'eglot)
  :config
  (add-hook 'eglot--managed-mode-hook (lambda () (flymake-mode -1))))
#+END_SRC

*** terraform-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package terraform-mode :ensure)
#+END_SRC

*** idris-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package idris-mode
  :defer
  :ensure
  :config
  (add-to-list 'completion-ignored-extensions ".ibc")
  )
#+END_SRC

*** go-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package go-mode
  :defer
  :ensure
  :config
  (setq flycheck-go-vet-executable "env CC=gcc go vet"))
#+END_SRC

*** undo-tree

Make undo more useful, and treelike.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package undo-tree
  :diminish
  :ensure
  :custom
  (undo-tree-auto-save-history nil)
  :config
  (global-undo-tree-mode)
  (defadvice undo-tree-visualize (around undo-tree-split-side-by-side activate)
    "Split undo-tree side-by-side"
    (let ((split-height-threshold nil)
          (split-width-threshold 0))
      ad-do-it)
    )
  :bind
  ("C-x u" . undo-tree-visualize)
  )
#+END_SRC

*** idle-highlight-mode

Highlight a variable when you're selecting it, helps in reviewing code to see
where it exists.

TODO: Add stuff like this? Future me figure it out.

(add-hook 'after-change-major-mode-hook
  (lambda ()
    (when (derived-mode-p 'c-mode)
      (setq-local idle-highlight-exceptions '("unsigned" "signed" "long" "int" "shot" "char")))
    (when (derived-mode-p 'python-mode)
      (setq-local idle-highlight-exceptions '("list" "tuple" "int" "float" "str" "bool")))))

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package idle-highlight-mode
  :ensure
  :custom (idle-highlight-idle-time 0.2)
  :hook ((prog-mode text-mode) . idle-highlight-mode))
#+END_SRC

*** nix

Instead of text might as well get a decent mode hook going here.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package nixos-options
  :defer
  :ensure)
(use-package company-nixos-options
  :after company
  :ensure)
#+END_SRC

**** nix-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package nix-mode :ensure :defer)
#+END_SRC

*** docker-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dockerfile-mode :ensure)
#+END_SRC

*** TODO cscope or rtags or nuke                         :testing:validation:

Switch to rtags, or maybe even nuke entirely?

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package xcscope
  :ensure
  :config (cscope-setup))
#+END_SRC

*** rg

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rg :ensure :defer)
#+END_SRC

* mode related

*** Reformatting

TODO: need to make this not auto format on _spec.sh buffers.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package apheleia
  :ensure
  :hook (prog-mode . apheleia-mode)
  :config
  (dolist (formatter '((shfmt-custom . ("altshfmt" "-ci" "-i" "2" "-bn" "-sr"))
                       (nix-custom   . ("nixpkgs-fmt")))
                       nil)
  (add-to-list #'apheleia-formatters formatter))

  (dolist (mode-formatter '((c-mode         . clang-format)
                           (emacs-lisp-mode . lisp-indent)
                           (nix-mode        . nix-custom)
                           (rust-mode       . rustfmt)
                           (go-mode         . gofmt)
                           (sh-mode         . shfmt-custom))
                         nil)
  (add-to-list #'apheleia-mode-alist mode-formatter)))
#+END_SRC

*** common defaults

Common mode defaults I think are sensible.

***** c

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.[chm]\\'" . c-mode))
(add-hook 'c-mode-common-hook
          '(lambda ()
             (global-set-key "\C-x\C-m" 'compile)
             (setq flycheck-clang-language-standard "c11")
             (setq flycheck-idle-change-delay 2)
             (setq flycheck-highlighting-mode 'symbols)
  ;; later...
  ;;             (add-hook 'before-save-hook 'clang-format-buffer nil t)
             (setq-default c-basic-offset 2
                           tab-width 2
                           indent-tabs-mode nil
                           c-electric-flag t
                           indent-level 2
                           c-default-style "bsd"
                           backward-delete-function nil)
             ))
#+END_SRC

***** shell

#+BEGIN_SRC emacs-lisp :tangle yes
(autoload 'sh--mode "sh-mode" "mode for shell stuff" t)

(add-to-list 'auto-mode-alist '("\\.sh$\\'" . sh-mode))
(add-to-list 'auto-mode-alist '("\\.[zk]sh$\\'" . sh-mode))
(add-to-list 'auto-mode-alist '("\\.bash$\\'" . sh-mode))
(add-to-list 'auto-mode-alist '("\\[.].*shrc$\\'" . sh-mode))
(add-to-list 'auto-mode-alist '("sourceme$\\'" . sh-mode))

(add-hook 'sh-mode-hook
          '(lambda ()
             (setq sh-basic-offset 2 sh-indentation 4
                   sh-indent-for-case-label 0 sh-indent-for-case-alt '+)))
#+END_SRC

***** perl

#+BEGIN_SRC emacs-lisp :tangle yes
(fset 'perl-mode 'cperl-mode)

(add-hook 'cperl-mode-hook
          '(lambda ()
             (setq indent-tabs-mode t)
             (setq tab-width 8)
             (setq cperl-indent-level 4)
             (setq tab-stop-list (number-sequence 4 200 4))
             (setq cperl-tab-always-indent t)
             (setq cperl-indent-parens-as-block t)
             )
          )
#+END_SRC

*** TODO auto-insert-mode new file templates                         :broken:

Review if this is worth keeping around, methinks there should be something
better like yasnippet out there, this is all old af hacks

Use auto-insert-mode to insert in templates for blank files.

So first up, add auto-insert to *find-file-hook* so we insert straight away. Also
setup the copyright bit to minimally put in name.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'find-file-hook 'auto-insert)
(defvar auto-insert-copyright (user-full-name))
#+END_SRC

Create *auto-insert-alist* so all the mode lists are the same

#+BEGIN_SRC emacs-lisp :tangle yes
(defvar auto-insert-alist '(()))
#+END_SRC

***** c

TODO: What use-package can I stick this in?

#+BEGIN_SRC emacs-lisp :tangle yes
(setq auto-insert-alist
      (append
       '(
         ((c-mode . "c")
          nil
          "/*\n"
          "SPDX-License-Identifier: BlueOak-1.0.0\n"
          "Description: " _ "\n"
          "*/\n"
          "#include <stdio.h>\n"
          "#include <stdlib.h>\n\n"
          "int main(int argc, char **argv) {\n"
          "  return 0;\n"
          "}\n"
          )
         )
       auto-insert-alist)
      )
#+END_SRC

***** elisp

TODO: What use-package can I stick this in?

#+BEGIN_SRC emacs-lisp :tangle yes
(setq auto-insert-alist
      (append
       '(
         ((emacs-lisp-mode . "elisp")
          nil
          ";;-*-mode: emacs-lisp; coding: utf-8;-*-\n"
          ";; SPDX-License-Identifier: BlueOak-1.0.0\n"
          ";; Description: " _ "\n"
          )
         )
       auto-insert-alist)
      )
#+END_SRC

***** python

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package python
  :config
  (setq auto-insert-alist
        (append
         '(((python-mode . "python")
            nil
            "#!/usr/bin/env python\n"
            "# -*-mode: Python; coding: utf-8;-*-\n"
            "# SPDX-License-Identifier: BlueOak-1.0.0\n"
            "# Description: " _ "\n\n"
            )
           )
         auto-insert-alist)
        )
)
#+END_SRC

***** shell

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package sh-script
  :config
  (setq auto-insert-alist
        (append
         '(
           ((sh-mode . "sh")
            nil
            "#!/usr/bin/env sh\n"
            "#-*-mode: Shell-script; coding: utf-8;-*-\n"
            "# SPDX-License-Identifier: BlueOak-1.0.0\n"
            "# Description: " _ "\n"
            "_base=$(basename \"$0\")\n"
            "_dir=$(cd -P -- \"$(dirname -- \"$(command -v -- \"$0\")\")\" && pwd -P || exit 126)\n"
            "export _base _dir\n"
            "set \"${SETOPTS:--eu}\"\n"
            )
           )
         auto-insert-alist)
        ))
#+END_SRC

*** desktop-save

Note: this is at the end so that anything that might get eval()'d from the desktop file can have been loaded by this point. Important as my org mode setup ordering requires some shenanigans.

Desktop saving of session information handy to keep the same buffers between sessions.

#+BEGIN_SRC emacs-lisp :tangle no
(defun desktop-setup ()

(require 'desktop)

(desktop-save-mode 1)

(custom-set-variables
 '(desktop-restore-eager 5)
 '(desktop-path '("~/.emacs.d"))
 '(desktop-dirname  "~/.emacs.d")
 '(desktop-base-file-name "desktop")
 )

(defun local-desktop-save ()
  (interactive)
  (if (eq (desktop-owner) (emacs-pid))
      (desktop-save desktop-dirname)))
)

(add-hook 'after-init-hook 'desktop-setup)
#+END_SRC

* custom

Load this up last to allow for local customization if needed and to keep from custom writing to the init.el file.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file 'noerror)
#+END_SRC

* TODO Load any local definitions                                    :broken:

Probably need to check if this file exists first...

#+BEGIN_SRC emacs-lisp :tangle no
(load-file "~/.emacs.d/local.el")
#+END_SRC

* TESTING

Stuff thats getting tested...

Giving this osx library a go, since I tend to only run gooey emacs on macos generally might as well make using the emacs on it a bit easier to use the say command and/or throw up notifications etc...
url: https://github.com/raghavgautam/osx-lib

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package osx-lib
  :if (memq window-system '(mac ns))
  :ensure)
#+END_SRC

Iffy.... Does some jank ass wack stuff in fullscreen mode on cocoa emacs in macos. Need to find a way to clamp the max rows it can display or something.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package mini-frame
  :ensure
  :config
  (mini-frame-mode t)
  :custom
  (mini-frame-show-parameters
   '((top . 10))))
  ;;    (width . 0.7)
  ;;    (left . 0.5))))
#+END_SRC

Ref:

- https://github.com/jrosdahl/fancy-dabbrev

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package fancy-dabbrev
  :diminish fancy-dabbrev-mode
  :ensure
  :bind (("TAB" . fancy-dabbrev-mode))
  :config
  (setq fancy-dabbrev-preview-delay 0.3)
  (setq fancy-dabbrev-expansion-on-preview-only t)
  (setq fancy-dabbrev-indent-command 'tab-to-tab-stop)
  (setq fancy-dabbrev-no-expansion-for '(multiple-cursors-mode magit-mode org-mode)))
#+END_SRC

ref: https://github.com/Malabarba/emacs-google-this

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package google-this
  :defer
  :ensure
  :config
  (google-this-mode 1))
#+END_SRC
