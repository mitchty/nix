#+TITLE: Emacs Configuration
#+AUTHOR: Mitchell Tishmack
#+STARTUP: hidestars
#+STARTUP: odd
#+BABEL: :cache yes
#+PROPERTY: header-args :cache yes
#+PROPERTY: header-args :padline no
#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: header-args :comments no
#+PROPERTY: header-args :results replace

* Emacs config

Use use-package to configure emacs itself.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package emacs
  :ensure
  :demand t
  :bind (("C-x ," . kill-whole-line)
         ("C-c %" . query-replace)) ;; because modern macos has yeeted this away from me...
  :config
  (setq-default debug-on-error t)
  (setq-default bidi-paragraph-direction 'left-to-right)
  (setq kill-buffer-query-functions
      (remq 'process-kill-buffer-query-function kill-buffer-query-functions))
  (show-paren-mode)
  (load "server")
  (unless (server-running-p) (server-start))
  (defun my-minibuffer-setup-hook ()
    (setq gc-cons-threshold most-positive-fixnum))
  (defun my-minibuffer-exit-hook ()
    (setq gc-cons-threshold 8000000))
  (defun string/ends-with (string suffix)
    "Return t if STRING ends with SUFFIX."
    (and (string-match (rx-to-string `(: ,suffix eos) t)
                       string)
         t))
  (defvar on-mswindows (string-match "windows" (symbol-name system-type))
    "Am I running under windows?")
  (defvar on-osx (string-match "darwin" (symbol-name system-type))
    "Am I running under osx?")
  (defvar on-linux (string-match "gnu/linux" (symbol-name system-type))
    "Am I running under linux?")
  (add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
  (add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook)
  (fset 'yes-or-no-p 'y-or-n-p)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq inhibit-startup-screen t)
  (setq enable-recursive-minibuffers t)
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
  (add-hook 'dired-load-hook (function (lambda () (load "dired-x"))))
  (put 'upcase-region 'disabled nil)

  (make-directory temporary-file-directory :parents)

  (delete-selection-mode 1)

  (set-language-environment "UTF-8")
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  :custom
  (locale-coding-system 'utf-8)
  (frame-inhibit-implied-resize t)
  (inhibit-startup-echo-area-message t)
  (inhibit-startup-message t)
  (inhibit-startup-screen t)
  (initial-scratch-message nil)
  (pixel-scroll-precision-mode t)
  (temporary-file-directory "/tmp/.emacs/")
  (backup-directory-alist `((".*" . ,temporary-file-directory)))
  (auto-save-file-name-transforms `((".*" ,temporary-file-directory t)))
  (create-lockfiles nil)
  (make-backup-files nil)
  (auto-save-default nil)
  (backup-by-copying t)
  (auto-save-list-file-prefix temporary-file-directory)

  (global-auto-revert-mode t)
  (auto-revert-remote-files t)
  (word-wrap t)
  (default-major-mode 'text-mode)
  (fill-column 80)
  (sentence-end "[.?!][]\"')]*\\($\\|\t\\| \\)[ \t\n]*")
  (sentence-end-double-space nil)
  (default-tab-width 2)
  (redisplay-dont-pause t)
  )
#+END_SRC

*** Testing area

TESTING tooltip mode

Puts all tooltips in the echo arear.

#+BEGIN_SRC emacs-lisp :tangle yes
(tooltip-mode -1)
(custom-set-variables
 '(tooltip-use-echo-area t))
#+END_SRC

*** use-package debugging

Cause the macros *use-packge* can generate are... not entirely easy to debug. This helps make it easier than using builtins.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package macrostep
  :ensure
  :after elisp-mode
  :bind
  (:map emacs-lisp-mode-map
        ("C-c e"   . macrostep-expand)
        ("C-c C-e" . macrostep-expand)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package nov
  :ensure
  :defer t
  :config
  (setq nov-text-width 80)
  :mode (("\\.epub\\'" . nov-mode)))
#+END_SRC

*** TESTING theme

Sick of solarized, going back to good old black on white minimalism like paper. Also note auto-dark is macos only.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package minimal-theme
  :ensure
  :config (load-theme 'minimal-light t))

(use-package zenburn-theme
  :ensure
  :config (load-theme 'zenburn t))

(use-package auto-dark
  :after minimal-theme
  :ensure
  :if (memq window-system '(mac ns))
  :init (auto-dark-mode)
  :custom
  (auto-dark--dark-theme 'zenburn)
  (auto-dark--light-theme 'minimal-light))
#+END_SRC

*** whitespace

Customize whitespace mode to make tabs obvious as boxes, and to highlight lines over 80 characters in length.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package hl-line
  :after org
  :ensure
  :hook ((prog-mode text-mode org-mode) . hl-line-mode)
  :custom-face
  (hl-line ((t (:background "#ffc0cb")))))
#+END_SRC

This breaks in :hook for some reason I can't be assed to figure out.

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'whitespace)
(global-visual-line-mode)
(setq whitespace-style '(face tabs trailing))

(set-face-attribute 'whitespace-tab nil
                    :foreground "#2075c7"
                    :background "lightgrey")

(set-face-attribute 'whitespace-line nil
                    :foreground "#2075c7"
                    :background "lightgrey")
(add-hook 'prog-mode-hook 'whitespace-mode)
(add-hook 'text-mode-hook 'whitespace-mode)
(add-hook 'makefile-mode-hook 'whitespace-mode)
(add-hook 'org-mode-hook 'whitespace-mode)
#+END_SRC

*** osx specific

**** no yes-or-no gui windows

On osx, don't ever display the gui dialog box. Taken from http://superuser.com/questions/125569/how-to-fix-emacs-popup-dialogs-on-mac-os-x

#+BEGIN_SRC emacs-lisp :tangle yes
(when (and on-osx (window-system))
  (defadvice yes-or-no-p (around prevent-dialog activate)
    "Prevent yes-or-no-p from activating a dialog"
    (let ((use-dialog-box nil))
      ad-do-it))
  (defadvice y-or-n-p (around prevent-dialog-yorn activate)
    "Prevent y-or-n-p from activating a dialog"
    (let ((use-dialog-box nil))
      ad-do-it))
  )
#+END_SRC

**** make osx gui emacs keyboard setup match console

Command should be meta on cocoa emacs like the old carbon/macports version.

#+BEGIN_SRC emacs-lisp :tangle yes
(when (and on-osx (window-system))
  (custom-set-variables
   '(mac-command-key-is-meta t)
   '(mac-option-key-is-meta nil)
   '(mac-command-key-is-meta t)
   '(mac-command-modifier 'meta)
   '(mac-option-modifier 'none)
   )
  )
#+END_SRC

*** x copy/paste

#+BEGIN_SRC emacs-lisp :tangle yes
(when (and on-linux (window-system))
  (progn
    (setq interprogram-paste-function 'x-cut-buffer-or-selection-value)
    (setq select-enable-clipboard t)
    )
  )
#+END_SRC
* appearance
*** focus on current text

TESTING
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dimmer
  :ensure t)
#+END_SRC

*** fonts setup

TODO: Migrate this into the top use-package setup
Set the default frame list values, then iff in a window system set the fonts in reverse order of preference

#+BEGIN_SRC emacs-lisp :tangle yes
(setq default-frame-alist
      (append (list
               '(right-fringe . 0)
               '(min-height . 1)
               '(height     . 42)
               '(foreground-color . "#333333")
               '(background-color . "#ffffff")
               '(cursor-color . "black")
               '(internal-border-width . 1)
               '(tool-bar-lines . 0)
               '(menu-bar-lines . 0))))
#+END_SRC

List of fonts in order of preference. Set preferred font list when we're in a gui emacs session. Note order of the list is in reverse so we set the least desired fonts and end with the more desired if available

#+BEGIN_SRC emacs-lisp :tangle yes
(with-no-warnings
  (mapcar (lambda (element)
            (when (and window-system (find-font (font-spec :name element))
                       (progn (set-frame-font element)
                              (set-face-attribute 'default nil :height 180))
                       )))
          '(
            "Monaco"
            "Menlo"
            "Source Code Pro"
            "Pragmata Pro" ;; Seems to register differently on osx than X
            "PragmataPro"
            "Comic Code"
            "ComicCode"
            )
          ))
#+END_SRC

*** tty

   Enable mouse mode for the console and use the mousewheel if possible.

#+BEGIN_SRC emacs-lisp :tangle yes
(unless window-system
  (require 'mouse)
  (xterm-mouse-mode t)
  (global-set-key [mouse-4] '(lambda ()
                               (interactive)
                               (scroll-down 1)))
  (global-set-key [mouse-5] '(lambda ()
                               (interactive)
                               (scroll-up 1)))
  (defun track-mouse (e))
  )
#+END_SRC

* packages

All the packages I use.
*** diminish

Keep useless mode line entries down a skosh.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package diminish :ensure)
#+END_SRC

*** editorconfig

If editorconfig is around use it.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package editorconfig
  :diminish
  :ensure
  :config
  (editorconfig-mode 1))
#+END_SRC

*** tramp

#+BEGIN_SRC emacs-lisp :tangle no
(use-package tramp
  :defer
  :ensure
  :custom
  (tramp-default-method "ssh")
  :config
  (add-to-list 'tramp-default-proxies-alist '(".*" "\`root\'" "/ssh:%h:"))
  )
#+END_SRC

*** exec-path-from-shell

Turns out that someone wrote this exact thing already. Yay get to drop my own crap.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :ensure
  :if (memq window-system '(mac ns))
  :config
  (exec-path-from-shell-initialize)
  )
#+END_SRC

*** silver searcher

Use the silver searcher for quick searches.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ag :ensure :defer)
#+END_SRC

*** osx-clipboard-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package osx-clipboard
  :ensure
  :if (memq window-system '(mac ns))
  :config
  (osx-clipboard-mode +1))
#+END_SRC

*** TESTING mode-line setup

Using some hacked together minimal mode line stuff now, spaceline is too much
oomph with all the crap it did.

Will try this other mode line out (seems to just block startup sooo no?).

#+BEGIN_SRC emacs-lisp :tangle no
(use-package smart-mode-line
  :ensure
  :config (sml/setup))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my-flycheck-lighter (state)
  "formats the mode-line fycheck error/warning/note junk"
  (let* ((counts (flycheck-count-errors flycheck-current-errors))
         (errorp (flycheck-has-current-errors-p state))
         (err (or (cdr (assq state counts)) "?"))
         (running (eq 'running flycheck-last-status-change)))
    (if (or errorp running) (format "•%s" err))))

(use-package mini-modeline
  :ensure
  :config
  (mini-modeline-mode)
  ;; (add-hook 'after-init-hook (mini-modeline-mode))
  :custom
  (mini-modeline-truncate-p nil)
  (mini-modeline-echo-duration 5)
  (mini-modeline-display-gui-line nil)
  (mini-modeline-r-format '((:eval
                             (when (and (bound-and-true-p flycheck-mode)
                                        (or flycheck-current-errors
                                            (eq 'running flycheck-last-status-change)))
                               (concat
                                " "
                                (cl-loop for state in '((error . "#FB4933")
                                                        (warning . "#FABD2F")
                                                        (info . "#83A598"))
                                         as lighter = (my-flycheck-lighter (car state))
                                         when lighter
                                         concat (propertize
                                                 lighter
                                                 'face `(:foreground ,(cdr state))))
                                )))
                            "%e %b %c"
                            (:eval (if (use-region-p)
                                       (if (eq (point) (region-beginning))
                                           (format "%%l … %d" (line-number-at-pos (region-end)))
                                         (format "%d … %%l" (line-number-at-pos (region-beginning))))
                                     ":%l")))))
#+END_SRC

*** yasnippet

#+BEGIN_SRC emacs-lisp :tangle no
(use-package yasnippet
  :ensure
  :init
  (setq yas-snippet-dirs
        '("~/.emacs.d/snippets"
          "~/.emacs.d/snippets-upstream"
          ))
  :config
  (yas/reload-all)
  :hook ((prog-mode text-mode org-mode) . yas-minor-mode))
#+END_SRC

*** expand-region

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package expand-region
  :ensure
  :bind ("C-]" . er/expand-region))
#+END_SRC

*** ivy/swiper/projectile

Switching to ivy mode+swiper

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile
  :defer
  :ensure
  :config
  (projectile-global-mode))

(use-package counsel
  :ensure
  :bind (("C-x C-f" . counsel-find-file)
         ("C-c g" . counsel-git)
         ("C-c j" . counsel-git-grep)
         ("C-c k" . counsel-ag)
         ("C-x l" . counsel-locate)
         ("C-S-o" . counsel-rhythmbox)
         ("C-c C-r" . ivy-resume))
  :custom
  (counsel-find-file-at-point t))

(use-package swiper
  :diminish
  :ensure
  :bind (("C-s" . swiper)
         ("M-x" . counsel-M-x))
  :config
  (ivy-mode 1)
  :custom
  (projectile-completion-system 'ivy)
  (magit-completing-read-function 'ivy-completing-read)
  (ivy-use-virtual-buffers t)
  (ivy-height 10)
  (ivy-count-format "(%d/%d) "))
#+END_SRC

*** magit

Make git not ass to use. At least in emacs. magit is the best git interface... in the world.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit
  :diminish
  :ensure
  :commands (magit-init
             magit-status
             magit-diff
             magit-commit)
  :bind ("C-x m" . magit-status)
  :custom
  (magit-auto-revert-mode nil)
  (magit-last-seen-setup-instructions "1.4.0")
  :config
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))
  (defadvice magit-quit-window (around magit-restore-screen activate)
    ad-do-it
    (jump-to-register :magit-fullscreen)))
#+END_SRC

And add TODO detection to the magit buffer. That way they get bubbled up to the
top to look at.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit-todos
  :ensure
  :after magit
  :hook (magit-mode . magit-todos-mode))
#+END_SRC

Also setup magit-lfs mode so we can do git lfs interaction.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit-lfs
  :ensure
  :after magit)
#+END_SRC

*** TODO org-mode                                        :validation:testing:

Org-mode keybindings and settings, pretty sparse really.

Todo is to figure out what needs to happen for the capture templates and
validate the agenda changes.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun capture-file-extension(extension)
  (if (eq extension nil) ""
    (if (string-match-p "\\." extension)
        extension
      (concat "." extension))))

(defun capture-date-file(path &optional extension)
  (setq prefix (expand-file-name (concat path (format-time-string "/%Y/%B"))))
  (mkdir prefix t)
  (setq file-name (format-time-string "%Y-%m-%d:%H:%M:%S"))
  (format "%s/%s%s" prefix file-name (capture-file-extension extension)))

(use-package ob-go :ensure)

(use-package org
  :defer
  :ensure
  :bind (("C-c a" . org-agenda)
         ("C-c b" . org-iswitchb)
         ("C-c c" . org-capture)
         ("C-c l" . org-store-link)
         ("C-c p" . org-latex-export-to-pdf))
  :config
  (add-to-list 'org-structure-template-alist '("el" . "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist '("hs" . "#+BEGIN_SRC haskell\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist '("pl" . "#+BEGIN_SRC perl\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist '("py" . "#+BEGIN_SRC python\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist '("sh" . "#+BEGIN_SRC sh\n?\n#+END_SRC"))
  (org-babel-do-load-languages
   'org-babel-load-languages
   (append org-babel-load-languages
           '(
             (C . t)
             (ditaa . t)
             (emacs-lisp . t)
             (go . t)
             (latex . t)
             (perl . t)
             (python . t)
             (ruby  . t)
             (shell . t)
             )))
  :custom
  (org-directory "~/src/pub/git.mitchty.net/mitchty/org")
  ;; Don't sort-lines ^^^
  (org-agenda-span 'fortnight)
  (org-archive-directory (concat org-directory "/attic"))
  (org-confirm-babel-evaluate nil)
  (org-default-notes-file (concat org-directory "/notes.org"))
  (org-fontify-done-headline t)
  (org-hide-emphasis-markers t)
  (org-hide-leading-stars t)
  (org-log-done t)
  (org-pretty-entities t)
  (org-src-preserve-indentation t)
  (org-src-strip-leading-and-trailing-blank-lines t)
  ;; Ref https://orgmode.org/manual/Template-elements.html for more detail.
  (org-agenda-files
   (list org-directory
         "~/src/pub/github.com/mitchty/nix"))
  ;;      "#+TITLE: %a\n#+ROAM_KEY: %U\n\n [[%U][%U]]\n"
  (org-capture-templates
   '(
;; TODO: make this crap work somehow
     ;; ("w" "website"
     ;;  entry (file (capture-date-file "~/src/org/ref/url" "org"))
     ;;  ;; "#+TITLE: %a\n#+ROAM_KEY: %U\n\n%? [[%U][%U]]\n"
     ;;  "%?"
     ;;  :prepend t :empty-lines 1)
     ;; ("u" "unsorted note"
     ;;  entry (file capture-date-file "~/src/org/unsorted" "org")
     ;;  "\n* %?\nRandom Note entered on %U\n  %i\n  %a\n"
     ;;  :prepend t :empty-lines 1)
     ;; ("r" "ref url"
     ;;  entry (file capture-date-file "~/src/org/ref/url")
     ;;  "\n* %?\nRandom Note entered on %U\n  %i\n  %a\n"
     ;;  :prepend t :empty-lines 1)
     ("d" "deadline"
      entry (file+headline org-default-notes-file "Todos")
      "* PRIO %? \nDEADLINE: %t"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     ("t" "todo"
      entry (file+headline org-default-notes-file "Todos")
      "* TODO %?\n  %i\n  %a\n"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     ("n" "note"
      entry (file+headline org-default-notes-file "Notes")
      "\n* %?\nRandom Note entered on %U\n  %i\n  %a\n"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     ("m" "email todo"
      entry (file+headline org-default-notes-file "Inbox")
      "\n* TODO %?, Link: %a\n"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     ("u" "urls"
      entry (file+headline org-default-notes-file "Urls")
      "\n** TODO read url :url:\n[[%?]]\n"
      :prepend t :empty-lines 1)
     ("i" "interruption"
      entry (file+headline org-default-notes-file "Interruptions")
      "\n* BLOCKED by %? :BLOCKED:\n%t"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     ("j" "journal"
      entry (file (concat org-directory "/journal.org"))
      "* %?\n%U\n"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     )))
#+END_SRC

**** TODO org babel ob-async testing                             :validation:

Validate that this installs from scratch fine, blocking babel executions is ass.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ob-async :after org :ensure)
#+END_SRC

**** TODO org-journal                                            :validation:

Try out org journal https://github.com/bastibe/org-journal

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-journal
  :ensure
  :defer
  :init
  (setq org-journal-prefix-key "C-c j ")
  :config
  (setq org-journal-dir (concat org-directory "/journal")
        org-journal-date-format "%A, %d %B %Y"))
#+END_SRC

**** TODO org-habit customization                                   :testing:

Figure out the customization needed here. Note that org-habit isn't a feature we can use-package against.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'org-modules 'org-habit)
(custom-set-variables
 '(org-habit-graph-column 44)
 '(org-habit-preceding-days 31)
 '(org-habit-following-days 7))
#+END_SRC

**** TODO org-bullets review if alternative is worth it          :validation:

https://github.com/integral-dw/org-superstar-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-bullets
  :after org
  :ensure
  :custom
  (org-bullets-bullet-list '("◉" "○" "✸" "✿" "✜" "◆" "▶"))
  (org-ellipsis "↴")
  :hook (org-mode . org-bullets-mode)
  :config
  (when window-system
    (let* ((variable-tuple (cond ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
                                 ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
                                 ((x-list-fonts "Verdana")         '(:font "Verdana"))
                                 ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
                                 (nil (warn "Cannot find a Sans Serif Font."))))
           (base-font-color     (face-foreground 'default nil 'default))
           (headline           `(:inherit default :weight bold :foreground ,base-font-color)))
      (custom-theme-set-faces 'user
                              `(org-level-8 ((t (,@headline ,@variable-tuple))))
                              `(org-level-7 ((t (,@headline ,@variable-tuple))))
                              `(org-level-6 ((t (,@headline ,@variable-tuple))))
                              `(org-level-5 ((t (,@headline ,@variable-tuple))))
                              `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
                              `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.25))))
                              `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.5))))
                              `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.75))))
                              `(org-document-title ((t (,@headline ,@variable-tuple :height 1.5 :underline nil)))))))
  (font-lock-add-keywords 'org-mode
                          '(("^ +\\([-*]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
  )
#+END_SRC

*** flycheck

Flycheck for on the fly checking of code.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck
  :ensure
  :custom
  (flycheck-indication-mode 'left-fringe)
  (flycheck-highlighting-mode 'symbols)
  (flycheck-highlighting-style 'level-face)
  :hook (prog-mode . flycheck-mode))
#+END_SRC

*** TODO wucuo

Spellcheek is useful.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package wucuo
  :ensure
  :hook (text-mode . #'wucuo-start))
#+END_SRC

*** auto-complete

Auto complete functionality is nice to have.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package auto-complete
  :ensure
  :init
  (require 'auto-complete-config)
  (ac-config-default)
  (global-auto-complete-mode t)
  )
#+END_SRC

*** smartparens

Helpfully inserts matching parens, can be a pita too.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smartparens
  :ensure
  :hook (prog-mode . smartparens-mode))
#+END_SRC

*** rainbow delimiters

Makes matching parens easier.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :ensure
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

*** uniquify

Make buffer names unique based on their directory and not have <N> or other nonsense.

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'uniquify)
(custom-set-variables '(uniquify-buffer-name-style 'post-forward))
#+END_SRC

*** super-save

REMOVE ME && TODO IF THIS WORKS

Saves buffers like with auto-save but on focus loss, when idle etc...

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package super-save
  :diminish
  :ensure
  :config
  (super-save-mode +1)
  (setq super-save-auto-save-when-idle t)
  (setq auto-save-default nil)
  )
#+END_SRC

*** TESTING diff-hl

Shows in the fringe the status of lines added/removed/modified. Seems a skosh slow.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package diff-hl
  :ensure
  :config
  (global-diff-hl-mode))
#+END_SRC

*** git gutter

#+BEGIN_SRC emacs-lisp :tangle no
(use-package git-gutter
  :ensure
  :config
  (global-git-gutter-mode t)
  )
#+END_SRC

*** clang-format

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package clang-format
  :ensure
  :bind (([C-M-tab] . clang-format-region))
  )
#+END_SRC

*** yaml-mode

For.. yaml

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yaml-mode
  :ensure
  :hook (yaml-mode . whitespace-mode)
  )
#+END_SRC

*** markdown-mode

Make markdown pretty(er/ish)

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package markdown-mode
  :ensure
  :hook (markdown-mode . whitespace-mode)
  )
#+END_SRC

*** writegood-mode

So I write gooder. Me fail English? Thats unpossible.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package writegood-mode :ensure)
#+END_SRC

*** rust-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rust-mode
  :diminish rust-mode
  :commands rust-mode
  :ensure
  )

(use-package rustic
  :after eglot
  :ensure
  ;; :bind (:map rustic-mode-map
  ;;             ("M-j" . lsp-ui-imenu)
  ;;             ("M-?" . lsp-find-references)
  ;;             ("C-c C-c l" . flycheck-list-errors)
  ;;             ("C-c C-c a" . lsp-execute-code-action)
  ;;             ("C-c C-c r" . lsp-rename)
  ;;             ("C-c C-c q" . lsp-workspace-restart)
  ;;             ("C-c C-c Q" . lsp-workspace-shutdown)
  ;;             ("C-c C-c s" . lsp-rust-analyzer-status))
  :config
  ;; uncomment for less flashiness
  ;; (setq lsp-eldoc-hook nil)
  ;; (setq lsp-enable-symbol-highlighting nil)
  ;; (setq lsp-signature-auto-activate nil)

  ;; comment to disable rustfmt on save
  (setq rustic-format-on-save t)
  (setq rustic-lsp-client 'eglot)
  (add-hook 'eglot--managed-mode-hook (lambda () (flymake-mode -1))))
;;   (add-hook 'rustic-mode-hook 'rk/rustic-mode-hook))

;; (defun rk/rustic-mode-hook ()
;;   ;; so that run C-c C-c C-r works without having to confirm, but don't try to
;;   ;; save rust buffers that are not file visiting. Once
;;   ;; https://github.com/brotzeit/rustic/issues/253 has been resolved this should
;;   ;; no longer be necessary.
;;   (when buffer-file-name
;;     (setq-local buffer-save-without-query t))
;;   (add-hook 'before-save-hook 'lsp-format-buffer nil t))
#+END_SRC

*** terraform-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package terraform-mode :ensure)
#+END_SRC

*** idris-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package idris-mode
  :defer
  :ensure
  :config
  (add-to-list 'completion-ignored-extensions ".ibc")
  )
#+END_SRC

*** go-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package go-mode
  :defer
  :ensure
  :config
  (setq flycheck-go-vet-executable "env CC=gcc go vet"))
#+END_SRC

*** undo-tree

Make undo more useful, and treelike.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package undo-tree
  :diminish
  :ensure
  :custom
  (undo-tree-auto-save-history nil)
  :config
  (global-undo-tree-mode)
  (defadvice undo-tree-visualize (around undo-tree-split-side-by-side activate)
    "Split undo-tree side-by-side"
    (let ((split-height-threshold nil)
          (split-width-threshold 0))
      ad-do-it)
    )
  :bind
  ("C-x u" . undo-tree-visualize)
  )
#+END_SRC

*** idle-highlight-mode

Highlight a variable when you're selecting it, helps in reviewing code to see
where it exists.

TODO: Add stuff like this? Future me figure it out.

(add-hook 'after-change-major-mode-hook
  (lambda ()
    (when (derived-mode-p 'c-mode)
      (setq-local idle-highlight-exceptions '("unsigned" "signed" "long" "int" "shot" "char")))
    (when (derived-mode-p 'python-mode)
      (setq-local idle-highlight-exceptions '("list" "tuple" "int" "float" "str" "bool")))))

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package idle-highlight-mode
  :ensure
  :custom (idle-highlight-idle-time 0.2)
  :hook ((prog-mode text-mode) . idle-highlight-mode))
#+END_SRC

*** nix

Instead of text might as well get a decent mode hook going here.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package nixos-options
  :defer
  :ensure)
(use-package company-nixos-options
  :after company
  :ensure)
#+END_SRC

**** nix-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package nix-mode :ensure :defer)
#+END_SRC

*** docker-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dockerfile-mode :ensure)
#+END_SRC

*** TODO cscope or rtags or nuke                         :testing:validation:

Switch to rtags, or maybe even nuke entirely?

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package xcscope
  :ensure
  :config (cscope-setup))
#+END_SRC

*** rg

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rg :ensure :defer)
#+END_SRC

* mode related
*** common defaults

Common mode defaults I think are sensible.

***** c

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.[chm]\\'" . c-mode))
(add-hook 'c-mode-common-hook
          '(lambda ()
             (global-set-key "\C-x\C-m" 'compile)
             (setq flycheck-clang-language-standard "c11")
             (setq flycheck-idle-change-delay 2)
             (setq flycheck-highlighting-mode 'symbols)
  ;; later...
  ;;             (add-hook 'before-save-hook 'clang-format-buffer nil t)
             (c-toggle-auto-state 1)
             (setq-default c-basic-offset 2
                           tab-width 2
                           indent-tabs-mode nil
                           c-electric-flag t
                           indent-level 2
                           c-default-style "bsd"
                           backward-delete-function nil)
             ))
#+END_SRC

***** shell

#+BEGIN_SRC emacs-lisp :tangle yes
(autoload 'sh--mode "sh-mode" "mode for shell stuff" t)

(add-to-list 'auto-mode-alist '("\\.sh$\\'" . sh-mode))
(add-to-list 'auto-mode-alist '("\\.[zk]sh$\\'" . sh-mode))
(add-to-list 'auto-mode-alist '("\\.bash$\\'" . sh-mode))
(add-to-list 'auto-mode-alist '("\\[.].*shrc$\\'" . sh-mode))
(add-to-list 'auto-mode-alist '("sourceme$\\'" . sh-mode))

(add-hook 'sh-mode-hook
          '(lambda ()
             (setq sh-basic-offset 2 sh-indentation 4
                   sh-indent-for-case-label 0 sh-indent-for-case-alt '+)))
#+END_SRC

***** perl

#+BEGIN_SRC emacs-lisp :tangle yes
(fset 'perl-mode 'cperl-mode)

(add-hook 'cperl-mode-hook
          '(lambda ()
             (setq indent-tabs-mode t)
             (setq tab-width 8)
             (setq cperl-indent-level 4)
             (setq tab-stop-list (number-sequence 4 200 4))
             (setq cperl-tab-always-indent t)
             (setq cperl-indent-parens-as-block t)
             )
          )
#+END_SRC

*** TODO auto-insert-mode new file templates                         :broken:

Review if this is worth keeping around, methinks there should be something
better like yasnippet out there, this is all old af hacks

Use auto-insert-mode to insert in templates for blank files.

So first up, add auto-insert to *find-file-hook* so we insert straight away. Also
setup the copyright bit to minimally put in name.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'find-file-hook 'auto-insert)
(defvar auto-insert-copyright (user-full-name))
#+END_SRC

Create *auto-insert-alist* so all the mode lists are the same

#+BEGIN_SRC emacs-lisp :tangle yes
(defvar auto-insert-alist '(()))
#+END_SRC

***** c

TODO: What use-package can I stick this in?

#+BEGIN_SRC emacs-lisp :tangle yes
(setq auto-insert-alist
      (append
       '(
         ((c-mode . "c")
          nil
          "/*\n"
          "SPDX-License-Identifier: BlueOak-1.0.0\n"
          "Description: " _ "\n"
          "*/\n"
          "#include <stdio.h>\n"
          "#include <stdlib.h>\n\n"
          "int main(int argc, char **argv) {\n"
          "  return 0;\n"
          "}\n"
          )
         )
       auto-insert-alist)
      )
#+END_SRC

***** elisp

TODO: What use-package can I stick this in?

#+BEGIN_SRC emacs-lisp :tangle yes
(setq auto-insert-alist
      (append
       '(
         ((emacs-lisp-mode . "elisp")
          nil
          ";;-*-mode: emacs-lisp; coding: utf-8;-*-\n"
          ";; SPDX-License-Identifier: BlueOak-1.0.0\n"
          ";; Description: " _ "\n"
          )
         )
       auto-insert-alist)
      )
#+END_SRC

***** python

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package python
  :config
  (setq auto-insert-alist
        (append
         '(((python-mode . "python")
            nil
            "#!/usr/bin/env python\n"
            "# -*-mode: Python; coding: utf-8;-*-\n"
            "# SPDX-License-Identifier: BlueOak-1.0.0\n"
            "# Description: " _ "\n\n"
            )
           )
         auto-insert-alist)
        )
)
#+END_SRC

***** shell

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package sh-script
  :hook (sh-mode . shfmtstuff)
  :config
  (setq auto-insert-alist
        (append
         '(
           ((sh-mode . "sh")
            nil
            "#!/usr/bin/env sh\n"
            "#-*-mode: Shell-script; coding: utf-8;-*-\n"
            "# SPDX-License-Identifier: BlueOak-1.0.0\n"
            "# Description: " _ "\n"
            "_base=$(basename \"$0\")\n"
            "_dir=$(cd -P -- \"$(dirname -- \"$(command -v -- \"$0\")\")\" && pwd -P || exit 126)\n"
            "export _base _dir\n"
            "set \"${SETOPTS:--eu}\"\n"
            )
           )
         auto-insert-alist)
        ))
#+END_SRC

*** desktop-save

Note: this is at the end so that anything that might get eval()'d from the desktop file can have been loaded by this point. Important as my org mode setup ordering requires some shenanigans.

Desktop saving of session information handy to keep the same buffers between sessions.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun desktop-setup ()

(require 'desktop)

(desktop-save-mode 1)

(custom-set-variables
 '(desktop-restore-eager 5)
 '(desktop-path '("~/.emacs.d"))
 '(desktop-dirname  "~/.emacs.d")
 '(desktop-base-file-name "desktop")
 )

(defun local-desktop-save ()
  (interactive)
  (if (eq (desktop-owner) (emacs-pid))
      (desktop-save desktop-dirname)))
)

(add-hook 'after-init-hook 'desktop-setup)
#+END_SRC

* custom

Load this up last to allow for local customization if needed and to keep from custom writing to the init.el file.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file 'noerror)
#+END_SRC

* TODO Load any local definitions                                    :broken:

Probably need to check if this file exists first...

#+BEGIN_SRC emacs-lisp :tangle no
(load-file "~/.emacs.d/local.el")
#+END_SRC

* TESTING

Stuff thats getting tested...

Iffy.... Does some jank ass wack stuff in fullscreen mode on cocoa emacs in macos.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package mini-frame
  :ensure
  :config
  (mini-frame-mode t)
  :custom
  (mini-frame-show-parameters
   '((top . 10))))
  ;;    (width . 0.7)
  ;;    (left . 0.5))))
#+END_SRC

Ref:

- https://github.com/jrosdahl/fancy-dabbrev

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package fancy-dabbrev
  :diminish fancy-dabbrev-mode
  :ensure
  :bind (("TAB" . fancy-dabbrev-mode))
  :config
  (setq fancy-dabbrev-preview-delay 0.3)
  (setq fancy-dabbrev-expansion-on-preview-only t)
  (setq fancy-dabbrev-indent-command 'tab-to-tab-stop)
  (setq fancy-dabbrev-no-expansion-for '(multiple-cursors-mode magit-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package eglot
  :ensure
  :hook ((python-mode cc-mode go-mode nix-mode yaml-mode rust-mode) . eglot-ensure))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
;; investigate this instead
;; (use-package apheleia
;;   :defer
;; ;;  :init
;; ;;  (apheleia-global-mode +1)
;;   :config
;;   (add-to-list 'apheleia-formatters '(shfmt     . ("shfmt" "-ci" "-p" "-i" "2" "-bn" "-sr")))
;;   (add-to-list 'apheleia-mode-alist '(haskell-mode    . hindent))
;;   (add-to-list 'apheleia-mode-alist '(emacs-lisp-mode . lisp-indent))
;;   (add-to-list 'apheleia-mode-alist '(rust-mode        . rustfmt))
;;   )
(use-package reformatter
 :ensure
 :config
 (progn
   (defvar shfmt-args '("-ci" "-p" "-i" "2" "-bn" "-sr")
     "shfmt default args")
   (reformatter-define shfmt
                       :program "shfmt"
                       :args shfmt-args))
 (defun shfmtstuff()
   (unless (or (eq sh-shell 'zsh) (string-match-p "_spec.sh" (buffer-file-name)))
     (shfmt-on-save-mode))))
#+END_SRC
