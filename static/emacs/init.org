#+TITLE: Emacs Configuration
#+AUTHOR: Mitchell Tishmack
#+STARTUP: hidestars
#+STARTUP: odd
#+BABEL: :cache yes
#+PROPERTY: header-args :cache yes
#+PROPERTY: header-args :padline no
#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: header-args :comments no
#+PROPERTY: header-args :results replace

* Emacs config

Use use-package to configure emacs itself.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package emacs
  :ensure
  :demand t
  :bind (("C-x ," . kill-whole-line)
         ("C-x %" . query-replace)) ;; because modern macos has yeeted this away from me...
  :config
  (setq-default debug-on-error t)
  (setq-default bidi-paragraph-direction 'left-to-right)
  (setq kill-buffer-query-functions
      (remq 'process-kill-buffer-query-function kill-buffer-query-functions))
  (show-paren-mode)
  (load "server")
  (unless (server-running-p) (server-start))
  (defun my-minibuffer-setup-hook ()
    (setq gc-cons-threshold most-positive-fixnum))
  (defun my-minibuffer-exit-hook ()
    (setq gc-cons-threshold 8000000))
  (defun string/ends-with (string suffix)
    "Return t if STRING ends with SUFFIX."
    (and (string-match (rx-to-string `(: ,suffix eos) t)
                       string)
         t))
  (defvar on-mswindows (string-match "windows" (symbol-name system-type))
    "Am I running under windows?")
  (defvar on-osx (string-match "darwin" (symbol-name system-type))
    "Am I running under osx?")
  (defvar on-linux (string-match "gnu/linux" (symbol-name system-type))
    "Am I running under linux?")
  (add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
  (add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook)
  (fset 'yes-or-no-p 'y-or-n-p)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq inhibit-startup-screen t)
  (setq enable-recursive-minibuffers t)
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
  (add-hook 'dired-load-hook (function (lambda () (load "dired-x"))))
  (put 'upcase-region 'disabled nil)

  (make-directory temporary-file-directory :parents)

  (delete-selection-mode 1)

  (set-language-environment "UTF-8")
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  :custom
  (locale-coding-system 'utf-8)
  (frame-inhibit-implied-resize t)
  (inhibit-startup-echo-area-message t)
  (inhibit-startup-message t)
  (inhibit-startup-screen t)
  (initial-scratch-message nil)
  (pixel-scroll-precision-mode t)
  (temporary-file-directory "/tmp/.emacs/")
  (backup-directory-alist `((".*" . ,temporary-file-directory)))
  (auto-save-file-name-transforms `((".*" ,temporary-file-directory t)))
  (create-lockfiles nil)
  (make-backup-files nil)
  (auto-save-default nil)
  (backup-by-copying t)
  (auto-save-list-file-prefix temporary-file-directory)

  (global-auto-revert-mode t)
  (auto-revert-remote-files t)
  (word-wrap t)
  (default-major-mode 'text-mode)
  (fill-column 80)
  (sentence-end "[.?!][]\"')]*\\($\\|\t\\| \\)[ \t\n]*")
  (sentence-end-double-space nil)
  (default-tab-width 2)
  (redisplay-dont-pause t)
  )
#+END_SRC

*** use-package debugging

Cause the macros *use-packge* can generate are... not entirely easy to debug. This helps make it easier than using builtins.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package macrostep
  :ensure
  :after elisp-mode
  :bind
  (:map emacs-lisp-mode-map
        ("C-c e"   . macrostep-expand)
        ("C-c C-e" . macrostep-expand)))
#+END_SRC

View epub's in emacs directly

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package nov
  :ensure
  :defer
  :config
  (setq nov-text-width 80)
  :mode (("\\.epub\\'" . nov-mode)))
#+END_SRC

minimap so my emacs can be more like the cool kids, won't turn it on everywhere yet only when i want it for now.

FUTURE MITCH DO NOT ADD *text-mode* or magit will get the minimap too probably a lot of other stuff too listen to jerk past you for once, this comment isn't here for funsies no cap.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package minimap
  :if (memq window-system '(mac ns))
  :ensure
  :defer
  :diminish minimap-mode
  :bind (("C-x i" . minimap-create))
  :custom
  (minimap-minimum-width 20)
  (minimap-major-modes '(prog-mode org-mode nix-mode))
  (minimap-recreate-window t)
  (minimap-update-delay 0)
  (minimap-window-location 'left))
#+END_SRC

*** TESTING theme

Sick of solarized, going back to good old black on white minimalism like paper. Also note auto-dark is macos only.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package zenburn-theme
  :ensure
  :config (load-theme 'zenburn t))

(use-package minimal-theme
  :ensure
  :config (load-theme 'minimal-light t))

(use-package auto-dark
  :if (memq window-system '(mac ns))
  :after (minimal-theme zenburn-theme)
  :ensure
  :defer
  :init
  ;; Its wack but if I don't have light go first some random face gets a grey color.
  (load-theme 'minimal-light t)
  (load-theme 'zenburn t)
  (load-theme 'minimal-light t)
  (auto-dark-mode)
  :custom
  (auto-dark--dark-theme 'zenburn)
  (auto-dark--light-theme 'minimal-light))
#+END_SRC

*** whitespace

Customize whitespace mode to make tabs obvious as boxes, and to highlight lines over 80 characters in length.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package hl-line
  :after org
  :ensure
  :defer
  :hook ((prog-mode text-mode org-mode) . hl-line-mode)
  :custom-face
  (hl-line ((t (:background "#ffc0cb")))))
#+END_SRC

This breaks in :hook for some reason I can't be assed to figure out.

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'whitespace)
(global-visual-line-mode)
(setq whitespace-style '(face tabs trailing))

(set-face-attribute 'whitespace-tab nil
                    :foreground "#2075c7"
                    :background "lightgrey")

(set-face-attribute 'whitespace-line nil
                    :foreground "#2075c7"
                    :background "lightgrey")
(add-hook 'prog-mode-hook 'whitespace-mode)
(add-hook 'text-mode-hook 'whitespace-mode)
(add-hook 'makefile-mode-hook 'whitespace-mode)
(add-hook 'org-mode-hook 'whitespace-mode)
#+END_SRC

*** osx specific

**** no yes-or-no gui windows

On osx, don't ever display the gui dialog box. Taken from http://superuser.com/questions/125569/how-to-fix-emacs-popup-dialogs-on-mac-os-x

#+BEGIN_SRC emacs-lisp :tangle yes
(when (and on-osx (window-system))
  (defadvice yes-or-no-p (around prevent-dialog activate)
    "Prevent yes-or-no-p from activating a dialog"
    (let ((use-dialog-box nil))
      ad-do-it))
  (defadvice y-or-n-p (around prevent-dialog-yorn activate)
    "Prevent y-or-n-p from activating a dialog"
    (let ((use-dialog-box nil))
      ad-do-it))
  )
#+END_SRC

**** make osx gui emacs keyboard setup match console

Command should be meta on cocoa emacs like the old carbon/macports version.

#+BEGIN_SRC emacs-lisp :tangle yes
(when (and on-osx (window-system))
  (custom-set-variables
   '(mac-command-key-is-meta t)
   '(mac-option-key-is-meta nil)
   '(mac-command-key-is-meta t)
   '(mac-command-modifier 'meta)
   '(mac-option-modifier 'none)
   )
  )
#+END_SRC

*** x copy/paste

#+BEGIN_SRC emacs-lisp :tangle yes
(when (and on-linux (window-system))
  (progn
    (setq interprogram-paste-function 'x-cut-buffer-or-selection-value)
    (setq select-enable-clipboard t)
    )
  )
#+END_SRC
* appearance
*** focus on current text

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dimmer
  :ensure t)
#+END_SRC

*** fonts setup

TODO: Migrate this into the top use-package setup
Set the default frame list values, then iff in a window system set the fonts in reverse order of preference

#+BEGIN_SRC emacs-lisp :tangle yes
(setq default-frame-alist
      (append (list
               '(right-fringe . 0)
               '(min-height . 1)
               '(height     . 42)
               '(foreground-color . "#333333")
               '(background-color . "#ffffff")
               '(cursor-color . "black")
               '(internal-border-width . 1)
               '(tool-bar-lines . 0)
               '(menu-bar-lines . 0))))
#+END_SRC

List of fonts in order of preference. Set preferred font list when we're in a gui emacs session. Note order of the list is in reverse so we set the least desired fonts and end with the more desired if available

#+BEGIN_SRC emacs-lisp :tangle yes
(with-no-warnings
  (mapcar (lambda (element)
            (when (and window-system (find-font (font-spec :name element))
                       (progn (set-frame-font element)
                              (set-face-attribute 'default nil :height 180))
                       )))
          '(
            "Monaco"
            "Menlo"
            "Source Code Pro"
            "Pragmata Pro" ;; Seems to register differently on osx than X
            "PragmataPro"
            "Comic Code"
            "ComicCode"
            )
          ))
#+END_SRC

*** tty

   Enable mouse mode for the console and use the mousewheel if possible.

#+BEGIN_SRC emacs-lisp :tangle yes
(unless window-system
  (require 'mouse)
  (xterm-mouse-mode t)
  (global-set-key [mouse-4] '(lambda ()
                               (interactive)
                               (scroll-down 1)))
  (global-set-key [mouse-5] '(lambda ()
                               (interactive)
                               (scroll-up 1)))
  (defun track-mouse (e))
  )
#+END_SRC

* packages

All the packages I use.
*** diminish

Keep useless mode line entries down a skosh.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package diminish :ensure)
#+END_SRC

*** editorconfig

If editorconfig is around use it.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package editorconfig
  :diminish
  :ensure
  :defer
  :config
  (editorconfig-mode 1))
#+END_SRC

*** tramp

#+BEGIN_SRC emacs-lisp :tangle yes
;; Turn vc mode off in find-file cause if its removed who gives a crap if its in
;; version control?

(defun vc-off-if-remote ()
  (if (file-remote-p (buffer-file-name))
      (setq-local vc-handled-backends nil)))
(add-hook 'find-file-hook 'vc-off-if-remote)

(use-package tramp
  :after emacs
  :custom
  (tramp-default-method "ssh")
  (vc-handled-backends '(Git))
  :config
  (add-to-list 'tramp-default-proxies-alist '(".*" "\`root\'" "/ssh:%h:"))
  )
#+END_SRC

*** exec-path-from-shell

Turns out that someone wrote this exact thing already. Yay get to drop my own crap.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  :ensure
  :config
  (exec-path-from-shell-initialize)
  )
#+END_SRC

*** silver searcher

Use the silver searcher for quick searches.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ag :ensure :defer)
#+END_SRC

*** osx-clipboard-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package osx-clipboard
  :if (memq window-system '(mac ns))
  :ensure
  :config
  (osx-clipboard-mode +1))
#+END_SRC

*** mode-line setup

Converted this all back to straight up manual mode line setup, all the packages take too much cpu and slow stuff down. Easier to just do what I want here than use all that extra elisp I don't use.

TODO: Need to customize the faces in the mode line to cover the atrocious
defaults. Future me task, also need to integrate my flycheck lighter in so I can
get error/warning/info summaries when present that link to the
errors/warnings/whatever. And put in the start..end region thing too to replace
line:column when a regions selected like I had. Mostly just copypastad a lot of
crap I found on github.

#+BEGIN_SRC emacs-lisp
(defun my-mode-line-fill (reserve)
  (let ((real-reserve (if (and window-system (eq 'right (get-scroll-bar-mode)))
                          (- reserve 3)
                        reserve)))
    (propertize " "
                'display `((space :align-to (- (+ right right-fringe right-margin) ,real-reserve))))))


(defun my-mode-line-fill-center (reserve)
  "Return empty space to the center of remaining space leaving RESERVE space on the right."
  (propertize " "
              'display `((space :align-to (- (+ center (0.5 . right-margin)) ,reserve
                                             (0.5 . left-margin))))))

(defun my-flycheck-lighter (state)
  "formats the mode-line fycheck error/warning/note junk"
  (let* ((counts (flycheck-count-errors flycheck-current-errors))
         (errorp (flycheck-has-current-errors-p state))
         (err (or (cdr (assq state counts)) "?"))
         (running (eq 'running flycheck-last-status-change)))
    (if (or errorp running) (format "•%s" err))))

(setq-default mode-line-format
  (list "%e"
        mode-line-front-space
        '(:eval (when (file-remote-p default-directory)
                  (propertize "%1@"
                              'mouse-face 'mode-line-highlight
                              'help-echo (concat "remote: " default-directory))))
        '(:eval (cond (buffer-read-only "%* ")
                      ((buffer-modified-p) "! ")
                      (t "  ")))
        '(:eval (propertize "%12b" 'face 'mode-line-buffer-id 'help-echo default-directory))
        ;; TODO: get this working from old mini-modeline setup and while at it
        ;; let it somehow propertize links to errors or something dunno.
        ;; '(:eval
        ;;                      (when (and (bound-and-true-p flycheck-mode)
        ;;                                 (or flycheck-current-errors
        ;;                                     (eq 'running flycheck-last-status-change)))
        ;;                        (concat
        ;;                         " "
        ;;                         (cl-loop for state in '((error . "#FB4933")
        ;;                                                 (warning . "#FABD2F")
        ;;                                                 (info . "#83A598"))
        ;;                                  as lighter = (my-flycheck-lighter (car state))
        ;;                                  when lighter
        ;;                                  concat (propertize
        ;;                                          lighter
        ;;                                          'face `(:foreground ,(cdr state))))
        ;;                         )))
        '(:eval (let* ((vc-state (if (stringp vc-mode)
                                     (let* ((branch-name (replace-regexp-in-string
                                                          (format "^\s*%s:?-?" (vc-backend buffer-file-name))
                                                          ""
                                                          vc-mode))
                                            (formatted-branch-name branch-name)
                                            (buffer-vc-state (vc-state buffer-file-name))
                                            (f (cond ((string= "up-to-date" buffer-vc-state)
                                                      '((:slant normal)))
                                                     (t
                                                      '((:slant italic))))))
                                       (propertize formatted-branch-name 'face f))
                                   ""))
                       (ctr (format-mode-line (list  vc-state))))
                  (list (my-mode-line-fill-center (/ (length ctr) 2))
                        ctr)))
        ;; TODO: Port this over too at some point in a boring meeting or
        ;; whatever, the examples I found for line/column number were easier to
        ;; put in but that could probably just be the else clause to if we're in
        ;; a region predicate? Future me figure out past me's a jerk and just
        ;; wants mini-modeline to stop being ass at not loading.
        ;; '(:eval (if (use-region-p)
        ;;                                (if (eq (point) (region-beginning))
        ;;                                    (format "%%l … %d" (line-number-at-pos (region-end)))
        ;;                                  (format "%d … %%l" (line-number-at-pos (region-beginning))))
        ;;                              ":%l"))
        '(:eval (let* ((row (format-mode-line (list (propertize "%l" 'help-echo "Line number"))))
                       (col (format-mode-line (list ":" (propertize "%c" 'help-echo "Column number"))))
                       (col-length (max 5 (+ (length col))))
                       (row-length (+ col-length (length row))))
                  (list
                   (my-mode-line-fill row-length)
                   row
                   (my-mode-line-fill col-length)
                   col)))))
#+END_SRC

*** yasnippet

#+BEGIN_SRC emacs-lisp :tangle no
(use-package yasnippet
  :ensure
  :init
  (setq yas-snippet-dirs
        '("~/.emacs.d/snippets"
          "~/.emacs.d/snippets-upstream"
          ))
  :config
  (yas/reload-all)
  :hook ((prog-mode text-mode org-mode) . yas-minor-mode))
#+END_SRC

*** expand-region

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package expand-region
  :ensure
  :bind ("C-]" . er/expand-region))
#+END_SRC

*** ivy/swiper/projectile

Switching to ivy mode+swiper

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile
  :defer
  :ensure
  :config
  (projectile-global-mode))

(use-package counsel
  :ensure
  :bind (("C-x C-f" . counsel-find-file)
         ("C-c g" . counsel-git)
         ("C-c j" . counsel-git-grep)
         ("C-c k" . counsel-ag)
         ("C-x l" . counsel-locate)
         ("C-S-o" . counsel-rhythmbox)
         ("C-c C-r" . ivy-resume))
  :custom
  (counsel-find-file-at-point t))

(use-package swiper
  :diminish
  :ensure
  :bind (("C-s" . swiper)
         ("M-x" . counsel-M-x))
  :config
  (ivy-mode 1)
  :custom
  (projectile-completion-system 'ivy)
  (magit-completing-read-function 'ivy-completing-read)
  (ivy-use-virtual-buffers t)
  (ivy-height 10)
  (ivy-count-format "(%d/%d) "))
#+END_SRC

*** magit

Make git not ass to use. At least in emacs. magit is the best git interface... in the world.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit
  :diminish
  :ensure
  :commands (magit-init
             magit-status
             magit-diff
             magit-commit)
  :bind ("C-x m" . magit-status)
  :custom
  (magit-auto-revert-mode nil)
  (magit-last-seen-setup-instructions "1.4.0")
  :config
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))
  (defadvice magit-quit-window (around magit-restore-screen activate)
    ad-do-it
    (jump-to-register :magit-fullscreen)))
#+END_SRC

And add TODO detection to the magit buffer. That way they get bubbled up to the
top to look at.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit-todos
  :ensure
  :after magit
  :hook (magit-mode . magit-todos-mode))
#+END_SRC

Also setup magit-lfs mode so we can do git lfs interaction.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit-lfs
  :ensure
  :after magit)
#+END_SRC

*** TODO org-mode                                        :validation:testing:

Org-mode keybindings and settings, pretty sparse really.

Todo is to figure out what needs to happen for the capture templates and
validate the agenda changes.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun capture-file-extension(extension)
  (if (eq extension nil) ""
    (if (string-match-p "\\." extension)
        extension
      (concat "." extension))))

(defun capture-date-file(path &optional extension)
  (setq prefix (expand-file-name (concat path (format-time-string "/%Y/%B"))))
  (mkdir prefix t)
  (setq file-name (format-time-string "%Y-%m-%d:%H:%M:%S"))
  (format "%s/%s%s" prefix file-name (capture-file-extension extension)))

(use-package ob-go :ensure)

(use-package org
  :defer
  :ensure
  :bind (("C-c a" . org-agenda)
         ("C-c b" . org-iswitchb)
         ("C-c c" . org-capture)
         ("C-c l" . org-store-link)
         ("C-c p" . org-latex-export-to-pdf))
  :init
  (require 'org-tempo)
  :config
  (add-to-list 'org-structure-template-alist '("cc" . "SRC c"))
  (add-to-list 'org-structure-template-alist '("el" . "SRC emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("go" . "SRC go"))
  (add-to-list 'org-structure-template-alist '("hs" . "SRC haskell"))
  (add-to-list 'org-structure-template-alist '("pl" . "SRC perl"))
  (add-to-list 'org-structure-template-alist '("py" . "SRC python"))
  (add-to-list 'org-structure-template-alist '("rs" . "src rust"))
  (add-to-list 'org-structure-template-alist '("sh" . "src sh"))
  (org-babel-do-load-languages
   'org-babel-load-languages
   (append org-babel-load-languages
           '(
             (C . t)
             (ditaa . t)
             (emacs-lisp . t)
             (go . t)
             (latex . t)
             (perl . t)
             (python . t)
             (ruby  . t)
             (shell . t)
             )))
  :custom
  (org-directory "~/src/pub/git.mitchty.net/mitchty/org")
  ;; Don't sort-lines ^^^
  (org-agenda-span 'fortnight)
  (org-archive-directory (concat org-directory "/attic"))
  (org-confirm-babel-evaluate nil)
  (org-default-notes-file (concat org-directory "/notes.org"))
  (org-fontify-done-headline t)
  (org-hide-emphasis-markers t)
  (org-hide-leading-stars t)
  (org-log-done t)
  (org-pretty-entities t)
  (org-src-preserve-indentation t)
  (org-src-strip-leading-and-trailing-blank-lines t)
  ;; Ref https://orgmode.org/manual/Template-elements.html for more detail.
  (org-agenda-files
   (list org-directory
         "~/src/pub/github.com/mitchty/nix"))
  ;;      "#+TITLE: %a\n#+ROAM_KEY: %U\n\n [[%U][%U]]\n"
  (org-capture-templates
   '(
;; TODO: make this crap work somehow
     ;; ("w" "website"
     ;;  entry (file (capture-date-file "~/src/org/ref/url" "org"))
     ;;  ;; "#+TITLE: %a\n#+ROAM_KEY: %U\n\n%? [[%U][%U]]\n"
     ;;  "%?"
     ;;  :prepend t :empty-lines 1)
     ;; ("u" "unsorted note"
     ;;  entry (file capture-date-file "~/src/org/unsorted" "org")
     ;;  "\n* %?\nRandom Note entered on %U\n  %i\n  %a\n"
     ;;  :prepend t :empty-lines 1)
     ;; ("r" "ref url"
     ;;  entry (file capture-date-file "~/src/org/ref/url")
     ;;  "\n* %?\nRandom Note entered on %U\n  %i\n  %a\n"
     ;;  :prepend t :empty-lines 1)
     ("d" "deadline"
      entry (file+headline org-default-notes-file "Todos")
      "* PRIO %? \nDEADLINE: %t"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     ("t" "todo"
      entry (file+headline org-default-notes-file "Todos")
      "* TODO %?\n  %i\n  %a\n"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     ("n" "note"
      entry (file+headline org-default-notes-file "Notes")
      "\n* %?\nRandom Note entered on %U\n  %i\n  %a\n"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     ("m" "email todo"
      entry (file+headline org-default-notes-file "Inbox")
      "\n* TODO %?, Link: %a\n"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     ("u" "urls"
      entry (file+headline org-default-notes-file "Urls")
      "\n** TODO read url :url:\n[[%?]]\n"
      :prepend t :empty-lines 1)
     ("i" "interruption"
      entry (file+headline org-default-notes-file "Interruptions")
      "\n* BLOCKED by %? :BLOCKED:\n%t"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     ("j" "journal"
      entry (file (concat org-directory "/journal.org"))
      "* %?\n%U\n"
      :prepend t :empty-lines 1 :clock-in t :clock-resume t)
     )))
#+END_SRC

**** TODO org babel ob-async testing                             :validation:

Validate that this installs from scratch fine, blocking babel executions is ass.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ob-async :after org :ensure)
#+END_SRC

**** TODO org-journal                                            :validation:

Try out org journal https://github.com/bastibe/org-journal

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-journal
  :ensure
  :defer
  :init
  (setq org-journal-prefix-key "C-c j ")
  :config
  (setq org-journal-dir (concat org-directory "/journal")
        org-journal-date-format "%A, %d %B %Y"))
#+END_SRC

**** TODO org-habit customization                                   :testing:

Figure out the customization needed here. Note that org-habit isn't a feature we can use-package against.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'org-modules 'org-habit)
(custom-set-variables
 '(org-habit-graph-column 44)
 '(org-habit-preceding-days 31)
 '(org-habit-following-days 7))
#+END_SRC

**** TODO org-bullets review if alternative is worth it          :validation:

https://github.com/integral-dw/org-superstar-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-bullets
  :after org
  :ensure
  :custom
  (org-bullets-bullet-list '("◉" "○" "✸" "✿" "✜" "◆" "▶"))
  (org-ellipsis "↴")
  :hook (org-mode . org-bullets-mode)
  :config
  (when window-system
    (let* ((variable-tuple (cond ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
                                 ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
                                 ((x-list-fonts "Verdana")         '(:font "Verdana"))
                                 ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
                                 (nil (warn "Cannot find a Sans Serif Font."))))
           (base-font-color     (face-foreground 'default nil 'default))
           (headline           `(:inherit default :weight bold :foreground ,base-font-color)))
      (custom-theme-set-faces 'user
                              `(org-level-8 ((t (,@headline ,@variable-tuple))))
                              `(org-level-7 ((t (,@headline ,@variable-tuple))))
                              `(org-level-6 ((t (,@headline ,@variable-tuple))))
                              `(org-level-5 ((t (,@headline ,@variable-tuple))))
                              `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
                              `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.25))))
                              `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.5))))
                              `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.75))))
                              `(org-document-title ((t (,@headline ,@variable-tuple :height 1.5 :underline nil)))))))
  (font-lock-add-keywords 'org-mode
                          '(("^ +\\([-*]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
  )
#+END_SRC

**** TODO org-download                                              :testing:

Start using this or try to deal with say screenshots for org-journal or whatever notes.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org-download
  :defer t
  :ensure
  :after org
  :config
  (require 'org-download)
  (add-hook 'dired-mode-hook 'org-download-enable))
#+END_SRC

*** flycheck

Flycheck for on the fly checking of code.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck
  :ensure
  :custom
  (flycheck-indication-mode 'left-fringe)
  (flycheck-highlighting-mode 'symbols)
  (flycheck-highlighting-style 'level-face)
  :hook (prog-mode . flycheck-mode))
#+END_SRC

*** TODO wucuo

Spellcheek is useful.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package wucuo
  :ensure
  :hook (text-mode . wucuo-mode))
#+END_SRC

*** auto-complete

Auto complete functionality is nice to have.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package auto-complete
  :ensure
  :init
  (require 'auto-complete-config)
  (ac-config-default)
  (global-auto-complete-mode t)
  )
#+END_SRC

*** smartparens

Helpfully inserts matching parens, can be a pita too.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smartparens
  :ensure
  :hook (prog-mode . smartparens-mode))
#+END_SRC

*** rainbow delimiters

Makes matching parens easier.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :ensure
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

*** uniquify

Make buffer names unique based on their directory and not have <N> or other nonsense.

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'uniquify)
(custom-set-variables '(uniquify-buffer-name-style 'post-forward))
#+END_SRC

*** super-save

REMOVE ME && TODO IF THIS WORKS

Saves buffers like with auto-save but on focus loss, when idle etc...

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package super-save
  :diminish
  :ensure
  :config
  (super-save-mode +1)
  (setq super-save-auto-save-when-idle t)
  (setq auto-save-default nil)
  )
#+END_SRC

*** TESTING diff-hl

Shows in the fringe the status of lines added/removed/modified. Seems a skosh slow.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package diff-hl
  :ensure
  :config
  (global-diff-hl-mode))
#+END_SRC

*** git gutter

#+BEGIN_SRC emacs-lisp :tangle no
(use-package git-gutter
  :ensure
  :config
  (global-git-gutter-mode t)
  )
#+END_SRC

*** clang-format

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package clang-format
  :ensure
  :bind (([C-M-tab] . clang-format-region))
  )
#+END_SRC

*** yaml-mode

For.. yaml

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yaml-mode
  :ensure
  :hook (yaml-mode . whitespace-mode)
  )
#+END_SRC

*** markdown-mode

Make markdown pretty(er/ish)

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package markdown-mode
  :ensure
  :hook (markdown-mode . whitespace-mode)
  )
#+END_SRC

*** writegood-mode

So I write gooder. Me fail English? Thats unpossible.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package writegood-mode :ensure)
#+END_SRC

*** rust-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rust-mode
  :diminish rust-mode
  :commands rust-mode
  :ensure
  )

(use-package rustic
  :after eglot
  :ensure
  ;; :bind (:map rustic-mode-map
  ;;             ("M-j" . lsp-ui-imenu)
  ;;             ("M-?" . lsp-find-references)
  ;;             ("C-c C-c l" . flycheck-list-errors)
  ;;             ("C-c C-c a" . lsp-execute-code-action)
  ;;             ("C-c C-c r" . lsp-rename)
  ;;             ("C-c C-c q" . lsp-workspace-restart)
  ;;             ("C-c C-c Q" . lsp-workspace-shutdown)
  ;;             ("C-c C-c s" . lsp-rust-analyzer-status))
  :config
  ;; uncomment for less flashiness
  ;; (setq lsp-eldoc-hook nil)
  ;; (setq lsp-enable-symbol-highlighting nil)
  ;; (setq lsp-signature-auto-activate nil)

  ;; comment to disable rustfmt on save
  (setq rustic-format-on-save t)
  (setq rustic-lsp-client 'eglot)
  (add-hook 'eglot--managed-mode-hook (lambda () (flymake-mode -1))))
;;   (add-hook 'rustic-mode-hook 'rk/rustic-mode-hook))

;; (defun rk/rustic-mode-hook ()
;;   ;; so that run C-c C-c C-r works without having to confirm, but don't try to
;;   ;; save rust buffers that are not file visiting. Once
;;   ;; https://github.com/brotzeit/rustic/issues/253 has been resolved this should
;;   ;; no longer be necessary.
;;   (when buffer-file-name
;;     (setq-local buffer-save-without-query t))
;;   (add-hook 'before-save-hook 'lsp-format-buffer nil t))
#+END_SRC

*** terraform-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package terraform-mode :ensure)
#+END_SRC

*** idris-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package idris-mode
  :defer
  :ensure
  :config
  (add-to-list 'completion-ignored-extensions ".ibc")
  )
#+END_SRC

*** go-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package go-mode
  :defer
  :ensure
  :config
  (setq flycheck-go-vet-executable "env CC=gcc go vet"))
#+END_SRC

*** undo-tree

Make undo more useful, and treelike.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package undo-tree
  :diminish
  :ensure
  :custom
  (undo-tree-auto-save-history nil)
  :config
  (global-undo-tree-mode)
  (defadvice undo-tree-visualize (around undo-tree-split-side-by-side activate)
    "Split undo-tree side-by-side"
    (let ((split-height-threshold nil)
          (split-width-threshold 0))
      ad-do-it)
    )
  :bind
  ("C-x u" . undo-tree-visualize)
  )
#+END_SRC

*** idle-highlight-mode

Highlight a variable when you're selecting it, helps in reviewing code to see
where it exists.

TODO: Add stuff like this? Future me figure it out.

(add-hook 'after-change-major-mode-hook
  (lambda ()
    (when (derived-mode-p 'c-mode)
      (setq-local idle-highlight-exceptions '("unsigned" "signed" "long" "int" "shot" "char")))
    (when (derived-mode-p 'python-mode)
      (setq-local idle-highlight-exceptions '("list" "tuple" "int" "float" "str" "bool")))))

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package idle-highlight-mode
  :ensure
  :custom (idle-highlight-idle-time 0.2)
  :hook ((prog-mode text-mode) . idle-highlight-mode))
#+END_SRC

*** nix

Instead of text might as well get a decent mode hook going here.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package nixos-options
  :defer
  :ensure)
(use-package company-nixos-options
  :after company
  :ensure)
#+END_SRC

**** nix-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package nix-mode :ensure :defer)
#+END_SRC

*** docker-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dockerfile-mode :ensure)
#+END_SRC

*** TODO cscope or rtags or nuke                         :testing:validation:

Switch to rtags, or maybe even nuke entirely?

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package xcscope
  :ensure
  :config (cscope-setup))
#+END_SRC

*** rg

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rg :ensure :defer)
#+END_SRC

* mode related

*** Reformatting

TODO: need to make this not auto format on _spec.sh buffers.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package apheleia
  :ensure
  :config
  (dolist (formatter '((shfmt-custom     . ("shfmt" "-ci" "-p" "-i" "2" "-bn" "-sr")))
                        nil)
  (add-to-list #'apheleia-formatters formatter))

  (dolist (mode-formatter '((emacs-lisp-mode . lisp-indent)
                           (rust-mode        . rustfmt)
                           (go-mode          . gofmt)
                           (sh-mode          . shfmt-custom))
                         nil)
  (add-to-list #'apheleia-mode-alist mode-formatter)))
#+END_SRC

*** common defaults

Common mode defaults I think are sensible.

***** c

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.[chm]\\'" . c-mode))
(add-hook 'c-mode-common-hook
          '(lambda ()
             (global-set-key "\C-x\C-m" 'compile)
             (setq flycheck-clang-language-standard "c11")
             (setq flycheck-idle-change-delay 2)
             (setq flycheck-highlighting-mode 'symbols)
  ;; later...
  ;;             (add-hook 'before-save-hook 'clang-format-buffer nil t)
             (c-toggle-auto-state 1)
             (setq-default c-basic-offset 2
                           tab-width 2
                           indent-tabs-mode nil
                           c-electric-flag t
                           indent-level 2
                           c-default-style "bsd"
                           backward-delete-function nil)
             ))
#+END_SRC

***** shell

#+BEGIN_SRC emacs-lisp :tangle yes
(autoload 'sh--mode "sh-mode" "mode for shell stuff" t)

(add-to-list 'auto-mode-alist '("\\.sh$\\'" . sh-mode))
(add-to-list 'auto-mode-alist '("\\.[zk]sh$\\'" . sh-mode))
(add-to-list 'auto-mode-alist '("\\.bash$\\'" . sh-mode))
(add-to-list 'auto-mode-alist '("\\[.].*shrc$\\'" . sh-mode))
(add-to-list 'auto-mode-alist '("sourceme$\\'" . sh-mode))

(add-hook 'sh-mode-hook
          '(lambda ()
             (setq sh-basic-offset 2 sh-indentation 4
                   sh-indent-for-case-label 0 sh-indent-for-case-alt '+)))
#+END_SRC

***** perl

#+BEGIN_SRC emacs-lisp :tangle yes
(fset 'perl-mode 'cperl-mode)

(add-hook 'cperl-mode-hook
          '(lambda ()
             (setq indent-tabs-mode t)
             (setq tab-width 8)
             (setq cperl-indent-level 4)
             (setq tab-stop-list (number-sequence 4 200 4))
             (setq cperl-tab-always-indent t)
             (setq cperl-indent-parens-as-block t)
             )
          )
#+END_SRC

*** TODO auto-insert-mode new file templates                         :broken:

Review if this is worth keeping around, methinks there should be something
better like yasnippet out there, this is all old af hacks

Use auto-insert-mode to insert in templates for blank files.

So first up, add auto-insert to *find-file-hook* so we insert straight away. Also
setup the copyright bit to minimally put in name.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'find-file-hook 'auto-insert)
(defvar auto-insert-copyright (user-full-name))
#+END_SRC

Create *auto-insert-alist* so all the mode lists are the same

#+BEGIN_SRC emacs-lisp :tangle yes
(defvar auto-insert-alist '(()))
#+END_SRC

***** c

TODO: What use-package can I stick this in?

#+BEGIN_SRC emacs-lisp :tangle yes
(setq auto-insert-alist
      (append
       '(
         ((c-mode . "c")
          nil
          "/*\n"
          "SPDX-License-Identifier: BlueOak-1.0.0\n"
          "Description: " _ "\n"
          "*/\n"
          "#include <stdio.h>\n"
          "#include <stdlib.h>\n\n"
          "int main(int argc, char **argv) {\n"
          "  return 0;\n"
          "}\n"
          )
         )
       auto-insert-alist)
      )
#+END_SRC

***** elisp

TODO: What use-package can I stick this in?

#+BEGIN_SRC emacs-lisp :tangle yes
(setq auto-insert-alist
      (append
       '(
         ((emacs-lisp-mode . "elisp")
          nil
          ";;-*-mode: emacs-lisp; coding: utf-8;-*-\n"
          ";; SPDX-License-Identifier: BlueOak-1.0.0\n"
          ";; Description: " _ "\n"
          )
         )
       auto-insert-alist)
      )
#+END_SRC

***** python

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package python
  :config
  (setq auto-insert-alist
        (append
         '(((python-mode . "python")
            nil
            "#!/usr/bin/env python\n"
            "# -*-mode: Python; coding: utf-8;-*-\n"
            "# SPDX-License-Identifier: BlueOak-1.0.0\n"
            "# Description: " _ "\n\n"
            )
           )
         auto-insert-alist)
        )
)
#+END_SRC

***** shell

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package sh-script
  :config
  (setq auto-insert-alist
        (append
         '(
           ((sh-mode . "sh")
            nil
            "#!/usr/bin/env sh\n"
            "#-*-mode: Shell-script; coding: utf-8;-*-\n"
            "# SPDX-License-Identifier: BlueOak-1.0.0\n"
            "# Description: " _ "\n"
            "_base=$(basename \"$0\")\n"
            "_dir=$(cd -P -- \"$(dirname -- \"$(command -v -- \"$0\")\")\" && pwd -P || exit 126)\n"
            "export _base _dir\n"
            "set \"${SETOPTS:--eu}\"\n"
            )
           )
         auto-insert-alist)
        ))
#+END_SRC

*** desktop-save

Note: this is at the end so that anything that might get eval()'d from the desktop file can have been loaded by this point. Important as my org mode setup ordering requires some shenanigans.

Desktop saving of session information handy to keep the same buffers between sessions.

#+BEGIN_SRC emacs-lisp :tangle no
(defun desktop-setup ()

(require 'desktop)

(desktop-save-mode 1)

(custom-set-variables
 '(desktop-restore-eager 5)
 '(desktop-path '("~/.emacs.d"))
 '(desktop-dirname  "~/.emacs.d")
 '(desktop-base-file-name "desktop")
 )

(defun local-desktop-save ()
  (interactive)
  (if (eq (desktop-owner) (emacs-pid))
      (desktop-save desktop-dirname)))
)

(add-hook 'after-init-hook 'desktop-setup)
#+END_SRC

* custom

Load this up last to allow for local customization if needed and to keep from custom writing to the init.el file.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file 'noerror)
#+END_SRC

* TODO Load any local definitions                                    :broken:

Probably need to check if this file exists first...

#+BEGIN_SRC emacs-lisp :tangle no
(load-file "~/.emacs.d/local.el")
#+END_SRC

* TESTING

Stuff thats getting tested...

Puts all tooltips in the echo arear.

#+BEGIN_SRC emacs-lisp :tangle yes
(tooltip-mode -1)
(custom-set-variables
 '(tooltip-use-echo-area t))
#+END_SRC

Giving this osx library a go, since I tend to only run gooey emacs on macos generally might as well make using the emacs on it a bit easier to use the say command and/or throw up notifications etc...
url: https://github.com/raghavgautam/osx-lib

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package osx-lib
  :if (memq window-system '(mac ns))
  :ensure)
#+END_SRC

Iffy.... Does some jank ass wack stuff in fullscreen mode on cocoa emacs in macos. Need to find a way to clamp the max rows it can display or something.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package mini-frame
  :ensure
  :config
  (mini-frame-mode t)
  :custom
  (mini-frame-show-parameters
   '((top . 10))))
  ;;    (width . 0.7)
  ;;    (left . 0.5))))
#+END_SRC

Ref:

- https://github.com/jrosdahl/fancy-dabbrev

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package fancy-dabbrev
  :diminish fancy-dabbrev-mode
  :ensure
  :bind (("TAB" . fancy-dabbrev-mode))
  :config
  (setq fancy-dabbrev-preview-delay 0.3)
  (setq fancy-dabbrev-expansion-on-preview-only t)
  (setq fancy-dabbrev-indent-command 'tab-to-tab-stop)
  (setq fancy-dabbrev-no-expansion-for '(multiple-cursors-mode magit-mode org-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package eglot
  :ensure
  :hook ((python-mode cc-mode go-mode nix-mode yaml-mode rust-mode) . eglot-ensure))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(use-package reformatter
  :defer
  :ensure
  :config
  (progn
   (defvar shfmt-args '("-ci" "-p" "-i" "2" "-bn" "-sr")
     "shfmt default args")
   (reformatter-define shfmt
                       :program "shfmt"
                       :args shfmt-args))
 (defun shfmtstuff()
   (unless (or (eq sh-shell 'zsh) (string-match-p "_spec.sh" (buffer-file-name)))
     (shfmt-on-save-mode))))
#+END_SRC

ref: https://github.com/Malabarba/emacs-google-this

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package google-this
  :defer
  :ensure
  :config
  (google-this-mode 1))
#+END_SRC
